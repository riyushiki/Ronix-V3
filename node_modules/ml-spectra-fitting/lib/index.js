'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var assignDeep = require('assign-deep');
var getMaxValue = require('ml-array-max');
var mlPeakShapeGenerator = require('ml-peak-shape-generator');
var LM = require('ml-levenberg-marquardt');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var assignDeep__default = /*#__PURE__*/_interopDefaultLegacy(assignDeep);
var getMaxValue__default = /*#__PURE__*/_interopDefaultLegacy(getMaxValue);
var LM__default = /*#__PURE__*/_interopDefaultLegacy(LM);

/**
 * This function calculates the spectrum as a sum of linear combination of gaussian and lorentzian functions. The pseudo voigt
 * parameters are divided in 4 batches. 1st: centers; 2nd: heights; 3th: widths; 4th: mu's ;
 * @param t Ordinate value
 * @param p Lorentzian parameters
 * @returns {*}
 */

function sumOfGaussianLorentzians(p) {
  return function (t) {
    let nL = p.length / 4;
    let result = 0;
    for (let i = 0; i < nL; i++) {
      result +=
        p[i + nL] * mlPeakShapeGenerator.PseudoVoigt.fct(t - p[i], p[i + nL * 2], p[i + nL * 3]);
    }
    return result;
  };
}

/**
 * This function calculates the spectrum as a sum of gaussian functions. The Gaussian
 * parameters are divided in 3 batches. 1st: centers; 2nd: height; 3th: widths;
 * @param t Ordinate values
 * @param p Gaussian parameters
 * @returns {*}
 */

function sumOfGaussians(p) {
  return function (t) {
    let nL = p.length / 3;
    let result = 0;
    for (let i = 0; i < nL; i++) {
      result += p[i + nL] * mlPeakShapeGenerator.Gaussian.fct(t - p[i], p[i + nL * 2]);
    }
    return result;
  };
}

/**
 * This function calculates the spectrum as a sum of lorentzian functions. The Lorentzian
 * parameters are divided in 3 batches. 1st: centers; 2nd: heights; 3th: widths;
 * @param t Ordinate values
 * @param p Lorentzian parameters
 * @returns {*}
 */

function sumOfLorentzians(p) {
  return function (t) {
    let nL = p.length / 3;
    let result = 0;
    for (let i = 0; i < nL; i++) {
      result += p[i + nL] * mlPeakShapeGenerator.Lorentzian.fct(t - p[i], p[i + nL * 2]);
    }
    return result;
  };
}

function checkInput(data, peaks, options) {
  let {
    shape = { kind: 'gaussian' },
    optimization = {
      kind: 'lm',
    },
  } = options;

  if (typeof shape.kind !== 'string') {
    throw new Error('kind should be a string');
  }

  let kind = shape.kind.toLowerCase().replace(/[^a-z]/g, '');

  let paramsFunc;
  let defaultParameters;
  switch (kind) {
    case 'gaussian':
      paramsFunc = sumOfGaussians;
      defaultParameters = {
        x: {
          init: (peak) => peak.x,
          max: (peak) => peak.x + peak.width * 2,
          min: (peak) => peak.x - peak.width * 2,
          gradientDifference: (peak) => peak.width * 2e-3,
        },
        y: {
          init: (peak) => peak.y,
          max: () => 1.5,
          min: () => 0,
          gradientDifference: () => 1e-3,
        },
        width: {
          init: (peak) => peak.width,
          max: (peak) => peak.width * 4,
          min: (peak) => peak.width * 0.25,
          gradientDifference: (peak) => peak.width * 2e-3,
        },
      };
      break;
    case 'lorentzian':
      paramsFunc = sumOfLorentzians;
      defaultParameters = {
        x: {
          init: (peak) => peak.x,
          max: (peak) => peak.x + peak.width * 2,
          min: (peak) => peak.x - peak.width * 2,
          gradientDifference: (peak) => peak.width * 2e-3,
        },
        y: {
          init: (peak) => peak.y,
          max: () => 1.5,
          min: () => 0,
          gradientDifference: () => 1e-3,
        },
        width: {
          init: (peak) => peak.width,
          max: (peak) => peak.width * 4,
          min: (peak) => peak.width * 0.25,
          gradientDifference: (peak) => peak.width * 2e-3,
        },
      };
      break;
    case 'pseudovoigt':
      paramsFunc = sumOfGaussianLorentzians;
      defaultParameters = {
        x: {
          init: (peak) => peak.x,
          max: (peak) => peak.x + peak.width * 2,
          min: (peak) => peak.x - peak.width * 2,
          gradientDifference: (peak) => peak.width * 2e-3,
        },
        y: {
          init: (peak) => peak.y,
          max: () => 1.5,
          min: () => 0,
          gradientDifference: () => 1e-3,
        },
        width: {
          init: (peak) => peak.width,
          max: (peak) => peak.width * 4,
          min: (peak) => peak.width * 0.25,
          gradientDifference: (peak) => peak.width * 2e-3,
        },
        mu: {
          init: (peak) => (peak.mu !== undefined ? peak.mu : 0.5),
          min: () => 0,
          max: () => 1,
          gradientDifference: () => 0.01,
        },
      };
      break;
    default:
      throw new Error('kind of shape is not supported');
  }

  let x = data.x;
  let maxY = getMaxValue__default['default'](data.y);
  let y = new Array(x.length);
  for (let i = 0; i < x.length; i++) {
    y[i] = data.y[i] / maxY;
  }

  for (let i = 0; i < peaks.length; i++) {
    peaks[i].y /= maxY;
  }

  let parameters = assignDeep__default['default']({}, optimization.parameters, defaultParameters);

  for (let key in parameters) {
    for (let par in parameters[key]) {
      if (!Array.isArray(parameters[key][par])) {
        parameters[key][par] = [parameters[key][par]];
      }
      if (
        parameters[key][par].length !== 1 &&
        parameters[key][par].length !== peaks.length
      ) {
        throw new Error(`The length of ${key}-${par} is not correct`);
      }
      for (let index = 0; index < parameters[key][par].length; index++) {
        if (typeof parameters[key][par][index] === 'number') {
          let value = parameters[key][par][index];
          parameters[key][par][index] = () => value;
        }
      }
    }
  }

  optimization.parameters = parameters;

  return {
    y,
    x,
    maxY,
    peaks,
    paramsFunc,
    optimization,
  };
}

const LEVENBERG_MARQUARDT = 1;

function selectMethod(optimizationOptions = {}) {
  let { kind, options } = optimizationOptions;
  kind = getKind(kind);
  switch (kind) {
    case LEVENBERG_MARQUARDT:
      return {
        algorithm: LM__default['default'],
        optimizationOptions: checkOptions(kind, options),
      };
    default:
      throw new Error(`Unknown kind algorithm`);
  }
}

function checkOptions(kind, options = {}) {
  // eslint-disable-next-line default-case
  switch (kind) {
    case LEVENBERG_MARQUARDT:
      return Object.assign({}, lmOptions, options);
  }
}

function getKind(kind) {
  if (typeof kind !== 'string') return kind;
  switch (kind.toLowerCase().replace(/[^a-z]/g, '')) {
    case 'lm':
    case 'levenbergmarquardt':
      return LEVENBERG_MARQUARDT;
    default:
      throw new Error(`Unknown kind algorithm`);
  }
}

const lmOptions = {
  damping: 1.5,
  maxIterations: 100,
  errorTolerance: 1e-8,
};

// const STATE_INIT = 0;
// const STATE_MIN = 1;
// const STATE_MAX = 2;
// const STATE_GRADIENT_DIFFERENCE = 3;

// const X = 0;
// const Y = 1;
// const WIDTH = 2;
// const MU = 3;

// const keys = ['x', 'y', 'width', 'mu'];
/**
 * Fits a set of points to the sum of a set of bell functions.
 * @param {object} data - An object containing the x and y data to be fitted.
 * @param {array} peaks - A list of initial parameters to be optimized. e.g. coming from a peak picking [{x, y, width}].
 * @param {object} [options = {}]
 * @param {object} [options.shape={}] - it's specify the kind of shape used to fitting.
 * @param {string} [options.shape.kind = 'gaussian'] - kind of shape; lorentzian, gaussian and pseudovoigt are supported.
 * @param {object} [options.optimization = {}] - it's specify the kind and options of the algorithm use to optimize parameters.
 * @param {object} [options.optimization.kind = 'lm'] - kind of algorithm. By default it's levenberg-marquardt.
 * @param {object} [options.optimization.parameters] - options of each parameter to be optimized e.g. For a gaussian shape
 *  it could have x, y and with properties, each of which could contain init, min, max and gradientDifference, those options will define the guess,
 *  the min and max value of the parameter (search space) and the step size to approximate the jacobian matrix respectively. Those options could be a number,
 *  array of numbers, callback, or array of callbacks. Each kind of shape has default parameters so it could be undefined.
 * @param {object} [options.optimization.parameters.x] - options for x parameter.
 * @param {number|callback|array<number|callback>} [options.optimization.parameters.x.init] - definition of the starting point of the parameter (the guess),
 *  if it is a callback the method pass the peak as the unique input, if it is an array the first element define the guess of the first peak and so on.
 * @param {number|callback|array<number|callback>} [options.optimization.parameters.x.min] - definition of the lower limit of the parameter,
 *  if it is a callback the method pass the peak as the unique input, if it is an array the first element define the min of the first peak and so on.
 * @param {number|callback|array<number|callback>} [options.optimization.parameters.x.max] - definition of the upper limit of the parameter,
 *  if it is a callback the method pass the peak as the unique input, if it is an array the first element define the max of the first peak and so on.
 * @param {number|callback|array<number|callback>} [options.optimization.parameters.x.gradientDifference] - definition of  the step size to approximate the jacobian matrix of the parameter,
 *  if it is a callback the method pass the peak as the unique input, if it is an array the first element define the gradientDifference of the first peak and so on.
 * @param {object} [options.optimization.options = {}] - options for the specific kind of algorithm.
 * @param {number} [options.optimization.options.timeout] - maximum time running before break in seconds.
 * @param {number} [options.optimization.options.damping=1.5]
 * @param {number} [options.optimization.options.maxIterations=100]
 * @param {number} [options.optimization.options.errorTolerance=1e-8]
 * @returns {object} - A object with fitting error and the list of optimized parameters { parameters: [ {x, y, width} ], error } if the kind of shape is pseudoVoigt mu parameter is optimized.
 */
function optimize(data, peakList, options = {}) {
  const { y, x, maxY, peaks, paramsFunc, optimization } = checkInput(
    data,
    peakList,
    options,
  );

  let parameters = optimization.parameters;

  let nbShapes = peaks.length;
  let parameterKey = Object.keys(parameters);
  let nbParams = nbShapes * parameterKey.length;
  let pMin = new Float64Array(nbParams);
  let pMax = new Float64Array(nbParams);
  let pInit = new Float64Array(nbParams);
  let gradientDifference = new Float64Array(nbParams);

  for (let i = 0; i < nbShapes; i++) {
    let peak = peaks[i];
    for (let k = 0; k < parameterKey.length; k++) {
      let key = parameterKey[k];
      let init = parameters[key].init;
      let min = parameters[key].min;
      let max = parameters[key].max;
      let gradientDifferenceValue = parameters[key].gradientDifference;
      pInit[i + k * nbShapes] = init[i % init.length](peak);
      pMin[i + k * nbShapes] = min[i % min.length](peak);
      pMax[i + k * nbShapes] = max[i % max.length](peak);
      gradientDifference[i + k * nbShapes] = gradientDifferenceValue[
        i % gradientDifferenceValue.length
      ](peak);
    }
  }

  let { algorithm, optimizationOptions } = selectMethod(optimization);

  optimizationOptions.minValues = pMin;
  optimizationOptions.maxValues = pMax;
  optimizationOptions.initialValues = pInit;
  optimizationOptions.gradientDifference = gradientDifference;

  let pFit = algorithm({ x, y }, paramsFunc, optimizationOptions);

  let { parameterError: error, iterations } = pFit;
  let result = { error, iterations, peaks };
  for (let i = 0; i < nbShapes; i++) {
    pFit.parameterValues[i + nbShapes] *= maxY;
    for (let k = 0; k < parameterKey.length; k++) {
      // we modify the optimized parameters
      peaks[i][parameterKey[k]] = pFit.parameterValues[i + k * nbShapes];
    }
  }

  return result;
}

exports.optimize = optimize;
