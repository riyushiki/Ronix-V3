'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var median = require('ml-array-median');
var isAnyArray = require('is-any-array');
var fill = require('ml-array-sequential-fill');
var SplineInterpolator = require('spline-interpolator');
var sd = require('ml-array-standard-deviation');
var mean = require('ml-array-mean');
var min = require('ml-array-min');
var max = require('ml-array-max');
var FFT = require('fft.js');
var mlGsd = require('ml-gsd');
var mlMatrix = require('ml-matrix');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var median__default = /*#__PURE__*/_interopDefaultLegacy(median);
var isAnyArray__default = /*#__PURE__*/_interopDefaultLegacy(isAnyArray);
var fill__default = /*#__PURE__*/_interopDefaultLegacy(fill);
var SplineInterpolator__default = /*#__PURE__*/_interopDefaultLegacy(SplineInterpolator);
var sd__default = /*#__PURE__*/_interopDefaultLegacy(sd);
var mean__default = /*#__PURE__*/_interopDefaultLegacy(mean);
var min__default = /*#__PURE__*/_interopDefaultLegacy(min);
var max__default = /*#__PURE__*/_interopDefaultLegacy(max);
var FFT__default = /*#__PURE__*/_interopDefaultLegacy(FFT);

/**
 * This function returns an array with absolute values
 * @param {Array<Number>} array
 * @return {Number}
 */
function xAbsolute(array) {
  let tmpArray = array.slice();
  for (let i = 0; i < tmpArray.length; i++) {
    if (tmpArray[i] < 0) tmpArray[i] *= -1;
  }

  return tmpArray;
}

/**
 * This function calculates the median after taking the reimAbsolute values of the points
 * @param {Array<Number>} array - the array that will be rotated
 * @return {Number}
 */
function xAbsoluteMedian(array) {
  return median__default['default'](xAbsolute(array));
}

/**
 * This function xAdd the first array by the second array or a constant value to each element of the first array
 * @param {Array<Number>} array1 - the array that will be rotated
 * @param {Array|Number} array2
 * @return {Array}
 */
function xAdd(array1, array2) {
  let isConstant = false;
  let constant;
  if (isAnyArray__default['default'](array2)) {
    if (array1.length !== array2.length) {
      throw new Error('sub: size of array1 and array2 must be identical');
    }
  } else {
    isConstant = true;
    constant = Number(array2);
  }

  let array3 = new Array(array1.length);
  if (isConstant) {
    for (let i = 0; i < array1.length; i++) {
      array3[i] = array1[i] + constant;
    }
  } else {
    for (let i = 0; i < array1.length; i++) {
      array3[i] = array1[i] + array2[i];
    }
  }

  return array3;
}

/**
 * This function xMultiply the first array by the second array or a constant value to each element of the first array
 * @param {Array} array1 - the array that will be rotated
 * @param {Array|Number} array2
 * @return {Float64Array}
 */
function xMultiply(array1, array2) {
  let isConstant = false;
  let constant;
  if (isAnyArray__default['default'](array2)) {
    if (array1.length !== array2.length) {
      throw new Error('sub: size of array1 and array2 must be identical');
    }
  } else {
    isConstant = true;
    constant = Number(array2);
  }

  let array3 = new Float64Array(array1.length);
  if (isConstant) {
    for (let i = 0; i < array1.length; i++) {
      array3[i] = array1[i] * constant;
    }
  } else {
    for (let i = 0; i < array1.length; i++) {
      array3[i] = array1[i] * array2[i];
    }
  }

  return array3;
}

function xDotProduct(A, B) {
  let g = xMultiply(A, B);
  let result = 0;
  for (let i = 0; i < A.length; i++) {
    result += g[i];
  }
  return result;
}

/**
 * Calculates the cross-correlation between 2 vectors
 * @param {Array<Number>} [A] - fixed array
 * @param {Array<Number>} [B] - sweeping array
 * @param {object} [options={}]
 * @param {number} [options.tau=1] - sweep increment size (in number of points, min=1, max=A.length)
 * @param {number} [options.lag=A.length - 1] - scalar lag parameter
 */

function xCrossCorrelation(A, B, options = {}) {
  let { tau = 1, lag = A.length - 1 } = options;
  let result = new Float64Array(1 + (2 * lag) / tau);
  if (A.length === B.length) {
    let n = B.length;
    let g = new Float64Array(2 * n);
    let q = new Float64Array(2 * n);
    for (let i = 0; i < n; i++) {
      q[n + i] = B[i];
    }
    for (let i = n * 2 - (tau - 1); i > 0; i -= tau) {
      let k = 0;
      for (let j = i; j < n * 2; j++) {
        g[k] = q[j];
        k++;
      }
      let w = [];
      for (let l = 0; l < n; l++) {
        w[l] = g[l];
      }
      result[(k - (n - lag)) / tau] = xDotProduct(A, w);
    }
  }
  return result;
}

/**
 * Calculates the auto-correlation of a vector
 * @param {Array<Number>} [A] - the array that will be fixed
 * @param {object} [options={}]
 * @param {number} [options.tau=1] - sweep increment size (in number of points, min=1, max=A.length)
 * @param {number} [options.lag=A.length - 1] - scalar lag parameter
 */

function xAutoCorrelation(A, options = {}) {
  return xCrossCorrelation(A, A, options);
}

/**
 * This function xSubtract the first array by the second array or a constant value from each element of the first array
 * @param {Array<Number>} array1 - the array that will be rotated
 * @return {object}
 */
function xBoxPlot(array) {
  array = array.slice(0).sort((a, b) => a - b);
  if (array.length < 5) {
    throw Error(
      'xBoxPlot: can not calculate info if array contains less than 3 elements',
    );
  }
  let info = {
    Q1: 0.0,
    Q2: 0.0,
    Q3: 0.0,
    min: array[0],
    max: array[array.length - 1],
  };
  let q1max, q3min;
  if (array.length % 2 === 1) {
    // odd
    let middle = (array.length - 1) / 2;
    info.Q2 = array[middle];
    q1max = middle - 1;
    q3min = middle + 1;
  } else {
    // even
    q3min = array.length / 2;
    q1max = q3min - 1;
    info.Q2 = (array[q1max] + array[q3min]) / 2;
  }
  if (q1max % 2 === 0) {
    info.Q1 = array[q1max / 2];
    info.Q3 = array[(array.length + q3min - 1) / 2];
  } else {
    info.Q1 = (array[(q1max + 1) / 2] + array[(q1max - 1) / 2]) / 2;
    let middleOver = (array.length + q3min) / 2;
    info.Q3 = (array[middleOver] + array[middleOver - 1]) / 2;
  }
  return info;
}

/**

/**
 * Calculates the correlation between 2 vectors
 * https://en.wikipedia.org/wiki/Correlation_and_dependence
 *
 * @param {Array<Number>} [A] - the array that will be rotated
 * @param {Array<Number>} [B]
 * @return {Array}
 */
function xCorrelation(A, B) {
  let n = A.length;
  let sumA = 0;
  let sumA2 = 0;
  let sumB = 0;
  let sumB2 = 0;
  let sumAB = 0;
  for (let i = 0; i < n; i++) {
    let a = A[i];
    let b = B[i];
    sumA += a;
    sumA2 += a ** 2;
    sumB += b;
    sumB2 += b ** 2;
    sumAB += a * b;
  }
  return (
    (n * sumAB - sumA * sumB) /
    (Math.sqrt(n * sumA2 - sumA ** 2) * Math.sqrt(n * sumB2 - sumB ** 2))
  );
}

/**
 * Calculate a new array of the same size that is the cumulative values
 * @param {Array<number>} isArray
 * @returns {Array<number}
 */
function xCumulative(array) {
  if (!isAnyArray__default['default'](array)) {
    throw new TypeError('input must be an array');
  }

  let newArray = new Float64Array(array.length);
  if (array.length < 1) return newArray;

  newArray[0] = array[0];
  for (let i = 1; i < array.length; i++) {
    newArray[i] = newArray[i - 1] + array[i];
  }
  return newArray;
}

/**
 * This function divide the first array by the second array or a constant value to each element of the first array
 * @param {Array<Number>} array1 - the array that will be rotated
 * @param {Array<Number>|Number} array2
 * @return {Array}
 */
function xDivide(array1, array2) {
  let isConstant = false;
  let constant;
  if (isAnyArray__default['default'](array2)) {
    if (array1.length !== array2.length) {
      throw new Error('sub: size of array1 and array2 must be identical');
    }
  } else {
    isConstant = true;
    constant = Number(array2);
  }

  let array3 = new Array(array1.length);
  if (isConstant) {
    for (let i = 0; i < array1.length; i++) {
      array3[i] = array1[i] / constant;
    }
  } else {
    for (let i = 0; i < array1.length; i++) {
      array3[i] = array1[i] / array2[i];
    }
  }

  return array3;
}

/**
 * Returns the closest index of a `target` in an ordered array
 * @param {array<Number>} array
 * @param {number} target
 */

function xFindClosestIndex(array, target) {
  let low = 0;
  let high = array.length - 1;
  let middle = 0;
  while (high - low > 1) {
    middle = low + ((high - low) >> 1);
    if (array[middle] < target) {
      low = middle;
    } else if (array[middle] > target) {
      high = middle;
    } else {
      return middle;
    }
  }

  if (low < array.length - 1) {
    if (Math.abs(target - array[low]) < Math.abs(array[low + 1] - target)) {
      return low;
    } else {
      return low + 1;
    }
  } else {
    return low;
  }
}

/**
 * Returns an object with {fromIndex, toIndex} for a specific from / to
 * @param {array} x
 * @param {object} [options={}]
 * @param {number} [options.from] - First value for xyIntegration in the X scale
 * @param {number} [options.fromIndex=0] - First point for xyIntegration
 * @param {number} [options.to] - Last value for xyIntegration in the X scale
 * @param {number} [options.toIndex=x.length-1] - Last point for xyIntegration
 */

function xGetFromToIndex(x, options = {}) {
  let { fromIndex, toIndex, from, to } = options;

  if (fromIndex === undefined) {
    if (from !== undefined) {
      fromIndex = xFindClosestIndex(x, from);
    } else {
      fromIndex = 0;
    }
  }
  if (toIndex === undefined) {
    if (to !== undefined) {
      toIndex = xFindClosestIndex(x, to);
    } else {
      toIndex = x.length - 1;
    }
  }
  if (fromIndex > toIndex) [fromIndex, toIndex] = [toIndex, fromIndex];
  return { fromIndex, toIndex };
}

/**
 *  Returns the targetIndex
 * @param {array} [x]
 * @param {object} [options={}]
 * @param {number} [options.target]
 * @param {number} [options.targetIndex=0]
 * @param {number}
 */

function xGetTargetIndex(x, options = {}) {
  let { target, targetIndex } = options;
  if (targetIndex === undefined) {
    if (target !== undefined) {
      return xFindClosestIndex(x, target);
    } else {
      return 0;
    }
  }
  return targetIndex;
}

/**
 * Checks if input is valdi
 * @param {Array<number>} input

 */
function xCheck(input) {
  if (!isAnyArray__default['default'](input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }
}

function xCheckLengths(array1, array2) {
  if (array1.length !== array2.length) {
    throw new TypeError('Length of array1 and array2 must be identical');
  }
}

/**
 * Computes the maximal value of an array of values
 * @param {Array<number>} array
 * @param {object} [options={}]
 * @param {number} [options.fromIndex=0] - First point for xyIntegration
 * @param {number} [options.toIndex=x.length-1] - Last point for xyIntegration
 * @return {number}
 */
function xMaxValue(array, options = {}) {
  xCheck(array);
  const { fromIndex = 0, toIndex = array.length - 1 } = options;
  let maxValue = array[fromIndex];

  for (let i = fromIndex + 1; i <= toIndex; i++) {
    if (array[i] > maxValue) {
      maxValue = array[i];
    }
  }
  return maxValue;
}

/**
 * Computes the minimal value of an array of values
 * @param {Array<number>} array
 * @param {object} [options={}]
 * @param {number} [options.fromIndex=0] - First point for xyIntegration
 * @param {number} [options.toIndex=x.length-1] - Last point for xyIntegration
 * @return {number}
 */
function xMinValue(array, options = {}) {
  xCheck(array);
  const { fromIndex = 0, toIndex = array.length - 1 } = options;
  let minValue = array[fromIndex];

  for (let i = fromIndex + 1; i <= toIndex; i++) {
    if (array[i] < minValue) {
      minValue = array[i];
    }
  }
  return minValue;
}

/**
 * Calculates an histogram of defined number of slots
 * @param {array} [array] Array containing values
 * @param {number} [options.nbSlots=256] Number of slots
 * @param {number} [options.min=minValue] Minimum value to calculate used to calculate slot size
 * @param {number} [options.max=maxValue] Maximal value to calculate used to calculate slot size
 * @param {number} [options.logBaseX] We can first apply a log on x axis
 * @param {number} [options.logBaseY] We can apply a log on the resulting histogram
 * @param {boolean} [options.absolute] Take the absolute value
 * @param {number} [options.centerX=true] Center the X value. We will enlarge the first and last values.
 * @param {DataXY} [options.histogram={x:[], y:[]}] Previously existing histogram to continue to fill
 * @return {DataXY} {x,y} of the histogram
 */

function xHistogram(array, options = {}) {
  xCheck(array);
  let histogram = options.histogram;
  const {
    centerX = true,
    nbSlots = histogram === undefined ? 256 : histogram.x.length,
    logBaseX,
    logBaseY,
    absolute = false,
  } = options;

  if (absolute) {
    array = xAbsolute(array);
  }

  if (logBaseX) {
    array = array.slice();
    const logOfBase = Math.log10(logBaseX);
    for (let i = 0; i < array.length; i++) {
      array[i] = Math.log10(array[i]) / logOfBase;
    }
  }

  const { min = xMinValue(array), max = xMaxValue(array) } = options;
  const slotSize = (max - min) / (nbSlots + Number.EPSILON);

  const y = histogram === undefined ? new Float64Array(nbSlots) : histogram.y;
  const x =
    histogram === undefined
      ? fill__default['default']({
          from: min + (centerX ? slotSize / 2 : 0),
          to: max - (centerX ? slotSize / 2 : 0),
          size: nbSlots,
        })
      : histogram.x;
  for (let i = 0; i < array.length; i++) {
    const index = Math.max(
      Math.min(
        ((array[i] - min - Number.EPSILON) / slotSize) >> 0,
        nbSlots - 1,
      ),
      0,
    );
    y[index]++;
  }

  if (logBaseY) {
    const logOfBase = Math.log10(logBaseY);
    for (let i = 0; i < y.length; i++) {
      y[i] = Math.log10(y[i] + 1) / logOfBase;
    }
  }

  return { x, y };
}

/**
 * Returns true if x is monotone
 * @param {Array} array
 * @return {boolean}
 */
function xIsMonotone(array) {
  if (array.length <= 2) {
    return true;
  }
  if (array[0] === array[1]) {
    // maybe a constant series
    for (let i = 1; i < array.length - 1; i++) {
      if (array[i] !== array[i + 1]) return false;
    }
    return true;
  }

  if (array[0] < array[array.length - 1]) {
    for (let i = 0; i < array.length - 1; i++) {
      if (array[i] >= array[i + 1]) return false;
    }
  } else {
    for (let i = 0; i < array.length - 1; i++) {
      if (array[i] <= array[i + 1]) return false;
    }
  }
  return true;
}

/**
 * Computes the index of the maximum of the given values
 * @param {Array<number>} array
 * @return {number}
 */
function xMaxIndex(array) {
  xCheck(array);

  let maxIndex = 0;

  for (let i = 1; i < array.length; i++) {
    if (array[i] > array[maxIndex]) {
      maxIndex = i;
    }
  }
  return maxIndex;
}

/**
 * Computes the maximal value of an array of values
 * @param {Array<number>} array
 * @param {object} [options={}]
 * @param {number} [options.fromIndex=0] - First point for xyIntegration
 * @param {number} [options.toIndex=x.length-1] - Last point for xyIntegration
 * @return {number}
 */
function xMean(array, options = {}) {
  xCheck(array);
  const { fromIndex = 0, toIndex = array.length - 1 } = options;
  let sumValue = array[fromIndex];

  for (let i = fromIndex + 1; i <= toIndex; i++) {
    sumValue += array[i];
  }
  return sumValue / (toIndex - fromIndex + 1);
}

/**
 * Computes the index of the minimum of the given values
 * @param {Array<number>} array
 * @return {number}
 */
function xMinIndex(array) {
  xCheck(array);
  let minIndex = 0;
  for (let i = 1; i < array.length; i++) {
    if (array[i] < array[minIndex]) {
      minIndex = i;
    }
  }
  return minIndex;
}

/**
import { xCheck } from './xCheck';
 * return min and max values of an array
 * @param {Array<number>} array
 * @returns {object} Object with 2 properties, min and max
 */
function xMinMaxValues(array) {
  xCheck(array);

  let min = array[0];
  let max = array[0];

  for (let value of array) {
    if (value < min) min = value;
    if (value > max) max = value;
  }

  return { min, max };
}

/* eslint-disable no-loss-of-precision */

/*
Adapted from: https://github.com/compute-io/erfcinv/blob/aa116e23883839359e310ad41a7c42f72815fc1e/lib/number.js

The MIT License (MIT)

Copyright (c) 2014-2015 The Compute.io Authors. All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute, and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the Software is furnished to do so, all subject to the following:

The copyright notices in the Software and this entire statement, including the above license grant, this restriction and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all derivative works of the Software, unless such copies or derivative works are solely in the form of machine-executable object code generated by a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// Coefficients for erfcinv on [0, 0.5]:
const Y1 = 8.91314744949340820313e-2;
const P1 = [
  -5.38772965071242932965e-3, 8.22687874676915743155e-3,
  2.19878681111168899165e-2, -3.65637971411762664006e-2,
  -1.26926147662974029034e-2, 3.34806625409744615033e-2,
  -8.36874819741736770379e-3, -5.08781949658280665617e-4,
];
const Q1 = [
  8.86216390456424707504e-4, -2.33393759374190016776e-3,
  7.95283687341571680018e-2, -5.27396382340099713954e-2,
  -7.1228902341542847553e-1, 6.62328840472002992063e-1, 1.56221558398423026363,
  -1.56574558234175846809, -9.70005043303290640362e-1, 1,
];

// Coefficients for erfcinv for 0.5 > 1-x >= 0:
const Y2 = 2.249481201171875;
const P2 = [
  -3.67192254707729348546, 2.11294655448340526258e1, 1.7445385985570866523e1,
  -4.46382324441786960818e1, -1.88510648058714251895e1,
  1.76447298408374015486e1, 8.37050328343119927838, 1.05264680699391713268e-1,
  -2.02433508355938759655e-1,
];
const Q2 = [
  1.72114765761200282724, -2.26436933413139721736e1, 1.08268667355460159008e1,
  4.85609213108739935468e1, -2.01432634680485188801e1,
  -2.86608180499800029974e1, 3.9713437953343869095, 6.24264124854247537712, 1,
];

// Coefficients for erfcinv for sqrt( -log(1-x)):
const Y3 = 8.07220458984375e-1;
const P3 = [
  -6.81149956853776992068e-10, 2.85225331782217055858e-8,
  -6.79465575181126350155e-7, 2.14558995388805277169e-3,
  2.90157910005329060432e-2, 1.42869534408157156766e-1,
  3.37785538912035898924e-1, 3.87079738972604337464e-1,
  1.17030156341995252019e-1, -1.63794047193317060787e-1,
  -1.31102781679951906451e-1,
];
const Q3 = [
  1.105924229346489121e-2, 1.52264338295331783612e-1, 8.48854343457902036425e-1,
  2.59301921623620271374, 4.77846592945843778382, 5.38168345707006855425,
  3.46625407242567245975, 1,
];

const Y4 = 9.3995571136474609375e-1;
const P4 = [
  2.66339227425782031962e-12, -2.30404776911882601748e-10,
  4.60469890584317994083e-6, 1.57544617424960554631e-4,
  1.87123492819559223345e-3, 9.50804701325919603619e-3,
  1.85573306514231072324e-2, -2.22426529213447927281e-3,
  -3.50353787183177984712e-2,
];
const Q4 = [
  7.64675292302794483503e-5, 2.63861676657015992959e-3,
  3.41589143670947727934e-2, 2.20091105764131249824e-1,
  7.62059164553623404043e-1, 1.3653349817554063097, 1,
];

const Y5 = 9.8362827301025390625e-1;
const P5 = [
  9.9055709973310326855e-17, -2.81128735628831791805e-14,
  4.62596163522878599135e-9, 4.49696789927706453732e-7,
  1.49624783758342370182e-5, 2.09386317487588078668e-4,
  1.05628862152492910091e-3, -1.12951438745580278863e-3,
  -1.67431005076633737133e-2,
];
const Q5 = [
  2.82243172016108031869e-7, 2.75335474764726041141e-5,
  9.64011807005165528527e-4, 1.60746087093676504695e-2,
  1.38151865749083321638e-1, 5.91429344886417493481e-1, 1,
];

function polyval(c, x) {
  let p = 0;
  for (const coef of c) {
    p = p * x + coef;
  }
  return p;
}

/**
 * Calculates a rational approximation.
 *
 * @private
 * @param {Number} x
 * @param {Number} v
 * @param {Array} P - array of polynomial coefficients
 * @param {Array} Q - array of polynomial coefficients
 * @param {Number} Y
 * @returns {Number} rational approximation
 */
function calc(x, v, P, Q, Y) {
  const s = x - v;
  const r = polyval(P, s) / polyval(Q, s);
  return Y * x + r * x;
}

/**
 * Evaluates the complementary inverse error function for an input value.
 *
 * @private
 * @param {Number} x - input value
 * @returns {Number} evaluated complementary inverse error function
 */
function erfcinv(x) {
  let sign = false;
  let val;
  let q;
  let g;
  let r;

  // [1] Special cases...

  // NaN:
  if (Number.isNaN(x)) {
    return NaN;
  }
  // x not on the interval: [0,2]
  if (x < 0 || x > 2) {
    throw new RangeError(
      `erfcinv()::invalid input argument. Value must be on the interval [0,2]. Value: \`${x}\`.`,
    );
  }
  if (x === 0) {
    return Number.POSITIVE_INFINITY;
  }
  if (x === 2) {
    return Number.NEGATIVE_INFINITY;
  }
  if (x === 1) {
    return 0;
  }
  // [2] Get the sign and make use of `erfc` reflection formula: `erfc(-z)=2 - erfc(z)`...
  if (x > 1) {
    q = 2 - x;
    x = 1 - q;
    sign = true;
  } else {
    q = x;
    x = 1 - x;
  }
  // [3] |x| <= 0.5
  if (x <= 0.5) {
    g = x * (x + 10);
    r = polyval(P1, x) / polyval(Q1, x);
    val = g * Y1 + g * r;
    return sign ? -val : val;
  }

  // [4] 1-|x| >= 0.25
  if (q >= 0.25) {
    g = Math.sqrt(-2 * Math.log(q));
    q = q - 0.25;
    r = polyval(P2, q) / polyval(Q2, q);
    val = g / (Y2 + r);
    return sign ? -val : val;
  }
  q = Math.sqrt(-Math.log(q));

  // [5] q < 3
  if (q < 3) {
    return calc(q, 1.125, P3, Q3, Y3);
  }
  // [6] q < 6
  if (q < 6) {
    return calc(q, 3, P4, Q4, Y4);
  }
  // Note that the smallest number in JavaScript is 5e-324. Math.sqrt( -Math.log( 5e-324 ) ) ~27.2844
  return calc(q, 6, P5, Q5, Y5);

  // Note that in the boost library, they are able to go to much smaller values, as 128 bit long doubles support ~1e-5000; something which JavaScript does not natively support.
}

function rayleighCdf(x, sigma = 1) {
  if (x < 0) {
    return 0;
  }
  return -Math.expm1(-Math.pow(x, 2) / (2 * Math.pow(sigma, 2)));
}

/**
 * Determine noise level by san plot methodology (https://doi.org/10.1002/mrc.4882)
 * @param {Array} data - real or magnitude spectra data.
 * @param {object} [options = {}]
 * @param {array} [options.mask] - boolean array to filter data, if the i-th element is true then the i-th element of the distribution will be ignored.
 * @param {number} [options.scaleFactor=1] - factor to scale the data input[i]*=scaleFactor.
 * @param {number} [options.cutOff] - percent of positive signal distribution where the noise level will be determined, if it is not defined the program calculate it.
 * @param {number} [options.factorStd=5] - factor times std to determine what will be marked as signals.
 * @param {boolean} [options.refine=true] - if true the noise level will be recalculated get out the signals using factorStd.
 * @param {boolean} [options.fixOffset=true] - If the baseline is correct, the midpoint of distribution should be zero. if true, the distribution will be centered.
 * @param {number} [options.logBaseY=2] - log scale to apply in the intensity axis in order to avoid big numbers.
 */

function xNoiseSanPlot(data, options = {}) {
  const {
    mask,
    cutOff,
    refine = true,
    magnitudeMode = false,
    scaleFactor = 1,
    factorStd = 5,
    fixOffset = true,
  } = options;

  let input;
  if (Array.isArray(mask) && mask.length === data.length) {
    input = new Float64Array(data.filter((_e, i) => !mask[i]));
  } else {
    input = new Float64Array(data);
  }

  if (scaleFactor > 1) {
    for (let i = 0; i < input.length; i++) {
      input[i] *= scaleFactor;
    }
  }
  input = input.sort().reverse();

  if (fixOffset && !magnitudeMode) {
    let medianIndex = Math.floor(input.length / 2);
    let median = 0.5 * (input[medianIndex] + input[medianIndex + 1]);
    for (let i = 0; i < input.length; i++) {
      input[i] -= median;
    }
  }

  let firstNegativeValueIndex =
    input[input.length - 1] >= 0 ? input.length : input.findIndex((e) => e < 0);
  let lastPositiveValueIndex = firstNegativeValueIndex - 1;
  for (let i = lastPositiveValueIndex; i >= 0; i--) {
    if (input[i] > 0) {
      lastPositiveValueIndex = i;
      break;
    }
  }

  let signPositive = input.slice(0, lastPositiveValueIndex + 1);
  let signNegative = input.slice(firstNegativeValueIndex);

  let cutOffDist = cutOff || determineCutOff(signPositive, { magnitudeMode });

  let pIndex = Math.floor(signPositive.length * cutOffDist);
  let initialNoiseLevelPositive = signPositive[pIndex];

  let skyPoint = signPositive[0];

  let initialNoiseLevelNegative;
  if (signNegative.length > 0) {
    let nIndex = Math.floor(signNegative.length * (1 - cutOffDist));
    initialNoiseLevelNegative = -1 * signNegative[nIndex];
  } else {
    initialNoiseLevelNegative = 0;
  }

  let noiseLevelPositive = initialNoiseLevelPositive;
  let noiseLevelNegative = initialNoiseLevelNegative;
  let cloneSignPositive = signPositive.slice();
  let cloneSignNegative = signNegative.slice();

  let cutOffSignalsIndexPlus = 0;
  let cutOffSignalsIndexNeg = 2;
  if (refine) {
    let cutOffSignals = noiseLevelPositive * factorStd;
    cutOffSignalsIndexPlus = signPositive.findIndex((e) => e < cutOffSignals);

    if (cutOffSignalsIndexPlus > -1) {
      cloneSignPositive = signPositive.slice(cutOffSignalsIndexPlus);
      noiseLevelPositive =
        cloneSignPositive[Math.floor(cloneSignPositive.length * cutOffDist)];
    }

    cutOffSignals = noiseLevelNegative * factorStd;
    cutOffSignalsIndexNeg = signNegative.findIndex((e) => e < cutOffSignals);
    if (cutOffSignalsIndexNeg > -1) {
      cloneSignNegative = signNegative.slice(cutOffSignalsIndexNeg);
      noiseLevelNegative =
        cloneSignPositive[
          Math.floor(cloneSignNegative.length * (1 - cutOffDist))
        ];
    }
  }
  let correctionFactor = -simpleNormInv(cutOffDist / 2, { magnitudeMode });
  initialNoiseLevelPositive = initialNoiseLevelPositive / correctionFactor;
  initialNoiseLevelNegative = initialNoiseLevelNegative / correctionFactor;

  let effectiveCutOffDist, refinedCorrectionFactor;

  if (refine && cutOffSignalsIndexPlus > -1) {
    effectiveCutOffDist =
      (cutOffDist * cloneSignPositive.length + cutOffSignalsIndexPlus) /
      (cloneSignPositive.length + cutOffSignalsIndexPlus);
    refinedCorrectionFactor =
      -1 * simpleNormInv(effectiveCutOffDist / 2, { magnitudeMode });

    noiseLevelPositive /= refinedCorrectionFactor;

    if (cutOffSignalsIndexNeg > -1) {
      effectiveCutOffDist =
        (cutOffDist * cloneSignNegative.length + cutOffSignalsIndexNeg) /
        (cloneSignNegative.length + cutOffSignalsIndexNeg);
      refinedCorrectionFactor =
        -1 * simpleNormInv(effectiveCutOffDist / 2, { magnitudeMode });
      if (noiseLevelNegative !== 0) {
        noiseLevelNegative /= refinedCorrectionFactor;
      }
    }
  } else {
    noiseLevelPositive /= correctionFactor;
    noiseLevelNegative /= correctionFactor;
  }

  return {
    positive: noiseLevelPositive,
    negative: noiseLevelNegative,
    snr: skyPoint / noiseLevelPositive,
    sanplot: generateSanPlot(input, {
      fromTo: {
        positive: { from: 0, to: lastPositiveValueIndex },
        negative: { from: firstNegativeValueIndex, to: input.length },
      },
    }),
  };
}

function determineCutOff(signPositive, options = {}) {
  let {
    magnitudeMode = false,
    considerList = { from: 0.5, step: 0.1, to: 0.9 },
  } = options;
  //generate a list of values for
  let cutOff = [];
  let indexMax = signPositive.length - 1;
  for (let i = 0.01; i <= 0.99; i += 0.01) {
    let index = Math.round(indexMax * i);
    let value =
      -signPositive[index] / simpleNormInv([i / 2], { magnitudeMode });
    cutOff.push([i, value]);
  }

  let minKi = Number.MAX_SAFE_INTEGER;
  let { from, to, step } = considerList;
  let delta = step / 2;
  let whereToCutStat = 0.5;
  for (let i = from; i <= to; i += step) {
    let floor = i - delta;
    let top = i + delta;
    let elementsOfCutOff = cutOff.filter((e) => e[0] < top && e[0] > floor);
    let averageValue = elementsOfCutOff.reduce((a, b) => a + Math.abs(b[1]), 0);
    let kiSqrt = 0;
    for (let j = 0; j < elementsOfCutOff.length; j++) {
      kiSqrt += Math.pow(elementsOfCutOff[j][1] - averageValue, 2);
    }

    if (kiSqrt < minKi) {
      minKi = kiSqrt;
      whereToCutStat = i;
    }
  }

  return whereToCutStat;
}

function simpleNormInv(data, options = {}) {
  const { magnitudeMode = false } = options;

  if (!Array.isArray(data)) data = [data];

  let from = 0;
  let to = 2;
  let step = 0.01;
  let xTraining = createArray(from, to, step);

  let result = new Float64Array(data.length);
  let yTraining = new Float64Array(xTraining.length);
  if (magnitudeMode) {
    let factor = 1;
    for (let i = 0; i < yTraining.length; i++) {
      let finalInput = xTraining[i] * factor;
      yTraining[i] = 1 - rayleighCdf(finalInput);
    }
    let interp = new SplineInterpolator__default['default'](xTraining, yTraining);
    for (let i = 0; i < result.length; i++) {
      let yValue = 2 * data[i];
      result[i] = -1 * interp.interpolate(yValue);
    }
  } else {
    for (let i = 0; i < result.length; i++) {
      result[i] = -1 * Math.SQRT2 * erfcinv(2 * data[i]);
    }
  }
  return result.length === 1 ? result[0] : result;
}

function createArray(from, to, step) {
  let result = new Array(Math.abs((from - to) / step + 1));
  for (let i = 0; i < result.length; i++) {
    result[i] = from + i * step;
  }
  return result;
}

function generateSanPlot(array, options = {}) {
  const { fromTo, logBaseY = 2 } = options;

  let sanplot = {};
  for (let key in fromTo) {
    let { from, to } = fromTo[key];
    sanplot[key] =
      from !== to
        ? scale(array.slice(from, to), {
            logBaseY,
          })
        : { x: [], y: [] };
    if (key === 'negative') {
      sanplot[key].y.reverse();
    }
  }
  return sanplot;
}

function scale(array, options = {}) {
  const { log10, abs } = Math;
  const { logBaseY } = options;
  if (logBaseY) {
    array = array.slice();
    const logOfBase = log10(logBaseY);
    for (let i = 0; i < array.length; i++) {
      array[i] = log10(abs(array[i])) / logOfBase;
    }
  }

  const xAxis = fill__default['default']({
    from: 0,
    to: array.length - 1,
    size: array.length,
  });

  return { x: xAxis, y: array };
}

/**
 * This function calculate the norm of a vector
 * @example xNorm([3, 4]) -> 5
 * @param {Array} array - the array that will be rotated
 * @return {number} calculated norm
 */
function xNorm(array) {
  let result = 0;
  for (let i = 0; i < array.length; i++) {
    result += array[i] ** 2;
  }
  return Math.sqrt(result);
}

/**
 * Pareto scaling, which uses the square root of standard deviation as the scaling factor, circumvents the amplification of noise by retaining a small portion of magnitude information.
 * Noda, I. (2008). Scaling techniques to enhance two-dimensional correlation spectra. Journal of Molecular Structure, 883, 216-227.
 * DOI: 10.1016/j.molstruc.2007.12.026
 * @param {Array<Number>} array
 * @return {Array}
 */
function xParetoNormalization(array) {
  xCheck(array);
  let result = [];
  const sqrtSD = Math.sqrt(sd__default['default'](array));

  for (let item of array) {
    result.push(item / sqrtSD);
  }
  return result;
}

/**
 * This function pads an array
 * @param {Array} array - the array that will be padded
 * @param {object} [options={}]
 * @param {string} [options.algorithm=''] '', value, circular, duplicate
 * @param {number} [options.size=0] padding size before first element and after last element
 * @param {number} [options.value=0] value to use for padding (if algorithm='value')
 * @return {Array}
 */
function xPadding(array, options = {}) {
  const { size = 0, value = 0, algorithm = '' } = options;
  xCheck(array);

  if (!algorithm) {
    if (array instanceof Float64Array) {
      return array.slice();
    } else {
      return Float64Array.from(array);
    }
  }

  let result = new Float64Array(array.length + size * 2);

  for (let i = 0; i < array.length; i++) {
    result[i + size] = array[i];
  }

  let fromEnd = size + array.length;
  let toEnd = 2 * size + array.length;

  switch (algorithm.toLowerCase()) {
    case 'value':
      for (let i = 0; i < size; i++) {
        result[i] = value;
      }
      for (let i = fromEnd; i < toEnd; i++) {
        result[i] = value;
      }
      break;
    case 'duplicate':
      for (let i = 0; i < size; i++) {
        result[i] = array[0];
      }
      for (let i = fromEnd; i < toEnd; i++) {
        result[i] = array[array.length - 1];
      }
      break;
    case 'circular':
      for (let i = 0; i < size; i++) {
        result[i] =
          array[(array.length - (size % array.length) + i) % array.length];
      }
      for (let i = 0; i < size; i++) {
        result[i + fromEnd] = array[i % array.length];
      }
      break;
    default:
      throw Error('xPadding: unknown algorithm');
  }

  return result;
}

/**
 * This function performs a circular shift to a new array
 * Positive values of shifts will shift to the right and negative values will do to the left
 * @example xRotate([1,2,3,4],1) -> [4,1,2,3]
 * @example xRotate([1,2,3,4],-1) -> [2,3,4,1]
 * @param {Array} array - the array that will be rotated
 * @param {number} shift
 * @return {Array}
 */
function xRotate(array, shift) {
  shift = shift % array.length;
  if (shift < 0) shift += array.length;
  let result = new Float64Array(array.length);
  result.set(array.slice(array.length - shift));
  result.set(array.slice(0, array.length - shift), shift);
  return result;
}

/**
 * This function calculates a rolling average
 * @param {Array<Number>} array - the array that will be rotated
 * @param {function} fct callback function that from an array returns a value.
 * @param {object} [options={}]
 * @param {number} [options.window=5] rolling window
 * @param {string} [options.padding.size=0] none, value, circular, duplicate
 * @param {string} [options.padding.algorithm='value'] none, value, circular, duplicate
 * @param {number} [options.padding.value=0] value to use for padding (if algorithm='value')
 * @return {Array<Number>}
 */
function xRolling(array, fct, options = {}) {
  xCheck(array);
  if (typeof fct !== 'function') throw Error('fct has to be a function');

  const { window = 5, padding = {} } = options;
  const { size = window - 1, algorithm, value } = padding;

  array = xPadding(array, { size, algorithm, value }); // ensure we get a copy and it is float64

  const newArray = [];
  for (let i = 0; i < array.length - window + 1; i++) {
    let subArray = new Float64Array(array.buffer, i * 8, window);
    // we will send a view to the original buffer
    newArray.push(fct(subArray));
  }

  return newArray;
}

/**
 * This function calculates a rolling average
 * @param {Array<Number>} array - the array that will be rotated
 * @param {object} [options={}]
 * @param {number} [options.window=5] rolling window
 * @param {string} [options.padding.size=window-1] none, value, circular, duplicate
 * @param {string} [options.padding.algorithm=''] none, value, circular, duplicate
 * @param {number} [options.padding.value=0] value to use for padding (if algorithm='value')
 * @return {Array<Number>}
 */
function xRollingAverage(array, options = {}) {
  return xRolling(array, mean__default['default'], options);
}

/**
 * This function calculates a rolling average
 * @param {Array<Number>} array - the array that will be rotated
 * @param {object} [options={}]
 * @param {number} [options.window=5] rolling window
 * @param {string} [options.padding.size=window-1] none, value, circular, duplicate
 * @param {string} [options.padding.algorithm=''] none, value, circular, duplicate
 * @param {number} [options.padding.value=0] value to use for padding (if algorithm='value')
 * @return {Array<Number>}
 */
function xRollingMedian(array, options = {}) {
  return xRolling(array, median__default['default'], options);
}

/**
 * This function calculates a minimum within a rolling window
 * @param {Array<Number>} array - the array that will be rotated
 * @param {object} [options={}]
 * @param {number} [options.window=5] rolling window
 * @param {string} [options.padding.size=window-1] none, value, circular, duplicate
 * @param {string} [options.padding.algorithm=''] none, value, circular, duplicate
 * @param {number} [options.padding.value=0] value to use for padding (if algorithm='value')
 * @return {Array<Number>}
 */
function xRollingMin(array, options = {}) {
  return xRolling(array, min__default['default'], options);
}

/**
 * This function calculates a maximum within a rolling window
 * @param {Array<Number>} array - the array that will be rotated
 * @param {object} [options={}]
 * @param {number} [options.window=5] rolling window
 * @param {string} [options.padding.size=window-1] none, value, circular, duplicate
 * @param {string} [options.padding.algorithm=''] none, value, circular, duplicate
 * @param {number} [options.padding.value=0] value to use for padding (if algorithm='value')
 * @return {Array<Number>}
 */
function xRollingMax(array, options = {}) {
  return xRolling(array, max__default['default'], options);
}

/**
 * This function xSubtract the first array by the second array or a constant value from each element of the first array
 * @param {Array} array1 - the array that will be rotated
 * @param {Array|Number} array2
 * @return {Array}
 */
function xSubtract(array1, array2) {
  let isConstant = false;
  let constant;
  if (isAnyArray__default['default'](array2)) {
    if (array1.length !== array2.length) {
      throw new Error('sub: size of array1 and array2 must be identical');
    }
  } else {
    isConstant = true;
    constant = Number(array2);
  }

  let array3 = new Array(array1.length);
  if (isConstant) {
    for (let i = 0; i < array1.length; i++) {
      array3[i] = array1[i] - constant;
    }
  } else {
    for (let i = 0; i < array1.length; i++) {
      array3[i] = array1[i] - array2[i];
    }
  }

  return array3;
}

/**
 * Calculate the sum of the values
 * @param {DataXY} [array={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.fromIndex=0] - First point for xSum
 * @param {number} [options.toIndex=x.length-1] - Last point for xSum
 * @return {number} xSum value on the specified range
 */

function xSum(array, options = {}) {
  const { fromIndex = 0, toIndex = array.length - 1 } = options;
  xCheck(array);

  let sumValue = array[fromIndex];
  for (let i = fromIndex + 1; i <= toIndex; i++) {
    sumValue += array[i];
  }
  return sumValue;
}

/**
 * This function calculates the mean absolute error
 * @param {Array<number>} array1 -
 * @param {Array<number>} array2
 * @return {Number}
 */
function xMeanAbsoluteError(array1, array2) {
  xCheckLengths(array1, array2);
  let sum = 0;
  for (let i = 0; i < array1.length; i++) {
    sum += Math.abs(array1[i] - array2[i]);
  }
  return sum / array1.length;
}

/**
 * This function calculates the mean squared error
 * @param {Array<number>} array1 -
 * @param {Array<number>} array2
 * @return {Number}
 */
function xMeanSquaredError(array1, array2) {
  xCheckLengths(array1, array2);
  let sum = 0;
  for (let i = 0; i < array1.length; i++) {
    sum += Math.pow(array1[i] - array2[i], 2);
  }
  return sum / array1.length;
}

function xUniqueSorted(array) {
  return Float64Array.from(new Set(array)).sort();
}

/**
 * Calculates reimAbsolute value of a complex spectrum
 * @param {object} [reim] - An object of kind {re:[], im:[]}.
 * @return {Float64Array}
 */
function reimAbsolute(data) {
  const length = data.re.length;
  const re = data.re;
  const im = data.im;
  const newArray = new Float64Array(length);
  for (let i = 0; i < length; i++) {
    newArray[i] = Math.sqrt(re[i] ** 2 + im[i] ** 2);
  }

  return newArray;
}

/**
 * Phase correction filter
 * @param {object} reim - An object of kind {re:[], im:[]}
 * @param {number} [phi0=0] - Angle in radians for zero order phase correction
 * @param {number} [phi1=0] - Angle in radians for first order phase correction
 * @return {object} returns a new object {re:[], im:[]}
 */
function reimPhaseCorrection(data, phi0, phi1) {
  phi0 = Number.isFinite(phi0) ? phi0 : 0;
  phi1 = Number.isFinite(phi1) ? phi1 : 0;

  const re = data.re;
  const im = data.im;
  const length = data.re.length;

  const delta = phi1 / length;
  const alpha = 2 * Math.pow(Math.sin(delta / 2), 2);
  const beta = Math.sin(delta);
  let cosTheta = Math.cos(phi0);
  let sinTheta = Math.sin(phi0);

  const newRe = new Float64Array(length);
  const newIm = new Float64Array(length);
  for (let i = 0; i < length; i++) {
    newRe[i] = re[i] * cosTheta - im[i] * sinTheta;
    newIm[i] = re[i] * sinTheta + im[i] * cosTheta;
    // calculate angles i+1 from i
    let newCosTheta = cosTheta - (alpha * cosTheta + beta * sinTheta);
    let newSinTheta = sinTheta - (alpha * sinTheta - beta * cosTheta);
    cosTheta = newCosTheta;
    sinTheta = newSinTheta;
  }

  return { re: newRe, im: newIm };
}

/**
 * Implementation of the algorithm for automatic phase correction: A robust, general automatic phase
 * correction algorithm for high-resolution NMR data. 10.1002/mrc.4586
 * @param {object} data - { re, im } real and imaginary data.
 * @param {object} options -
 * @param {Number} options.minRegSize - min number of points to auto phase a region.
 * @param {Number} options.maxDistanceToJoin - max distance between regions (in number of points) to join two regions
 * @param {boolean} options.magnitudeMode - if true it uses magnitude spectrum.boolean
 * @param {Number} options.factorNoise - scale the cutoff like factorStd * noiseLevel.
 */

const defaultOptions = {
  minRegSize: 30,
  maxDistanceToJoin: 256,
  magnitudeMode: true,
  factorNoise: 3,
};

function reimAutoPhaseCorrection(data, options = {}) {
  const { re, im } = data;
  const length = re.length;

  options = Object.assign(defaultOptions, options);

  const { magnitudeMode, minRegSize } = options;

  let magnitudeData = magnitudeMode ? reimAbsolute(data) : re;

  let ds = holoborodko(magnitudeData);
  let peaksDs = robustBaseLineRegionsDetection(ds, options);
  let peaksSp = robustBaseLineRegionsDetection(magnitudeData, options);
  let finalPeaks = new Array(length);
  for (let i = 0; i < length; i++) {
    finalPeaks[i] = peaksSp[i] & peaksDs[i];
  }

  // Once the regions are detected, we auto phase each of them separately.
  // TODO: This part can be put inside a function
  let i = -1;
  let x0 = 0;
  let res = [];
  while (i < length) {
    //phase first region
    let reTmp = [];
    let imTmp = [];

    //Look for the first 1 in the array
    while (!finalPeaks[++i] && i < length) {
      //TODO: Add some extra points(0.1 ppm) at rigth and left sides of the region.
      x0 = i;
    }
    for (; finalPeaks[i] && i < length; i++) {
      reTmp.push(re[i]);
      imTmp.push(im[i]);
      i++;
    }

    if (reTmp.length > minRegSize) {
      res.push(autoPhaseRegion(reTmp, imTmp, x0));
    }
  }
  // TODO: Still some corrections needed. In the paper they remove the outlayers interatively
  // until they can perform a regression witout bad points. Can someone help here?
  let [ph1, ph0] = weightedLinearRegression(
    res.map((r) => r.x0 / length),
    res.map((r) => r.ph0),
    res.map((r) => r.area / 1e11),
  );
  let phased = reimPhaseCorrection(
    { re, im },
    (ph0 * Math.PI) / 180,
    (ph1 * Math.PI) / 180,
  );
  return { data: phased, ph0, ph1 };
}

function autoPhaseRegion(re, im, x0) {
  let start = -180;
  let stop = 180;
  let nSteps = 6;
  let maxSteps = 5;

  let bestAng = 0;
  let minArea = Number.MAX_SAFE_INTEGER;
  while (maxSteps > 0) {
    let dAng = (stop - start) / (nSteps + 1);
    for (let i = start; i <= stop; i += dAng) {
      let phased = reimPhaseCorrection({ re, im }, toRadians(i), 0);
      let negArea = getNegArea(phased.re);
      if (negArea < minArea) {
        [minArea, bestAng] = [negArea, i];
      }
    }
    start = bestAng - dAng;
    stop = bestAng + dAng;
    maxSteps--;
  }

  // Calculate the area for the best angle
  let phased = reimPhaseCorrection({ re, im }, toRadians(bestAng), 0);
  let area = 0;
  let sumX = 0;
  for (let j = 0; j < re.length; j++) {
    area += phased.re[j];
    sumX += phased.re[j] * (j + x0);
  }

  return { ph0: bestAng, area, x0: sumX / area };
}

function holoborodko(s) {
  let dk = new Float64Array(s.length);
  for (let i = 5; i < s.length - 5; i++) {
    dk[i] =
      (42 * (s[i + 1] - s[i - 1]) +
        48 * (s[i + 2] - s[i - 2]) +
        27 * (s[i + 3] + s[i - 3]) +
        8 * (s[i + 4] - s[i - 4]) +
        s[i + 5] -
        s[i - 5]) /
      512;
  }
  //Fill the borders
  for (let i = 0; i < 5; i++) {
    dk[i] = dk[5];
    dk[s.length - i - 1] = dk[s.length - 6];
  }

  return dk;
}

function robustBaseLineRegionsDetection(s, options) {
  const { maxDistanceToJoin, magnitudeMode, factorNoise } = options;

  let mask = new Array(s.length);
  for (let i = 0; i < s.length; i++) {
    mask[i] = false;
  }

  let change = true;
  while (change) {
    let noiseLevel = xNoiseSanPlot(s, { magnitudeMode });
    let cutOff = factorNoise * noiseLevel.positive;
    change = false;
    for (let i = 0; i < s.length; i++) {
      if (Math.abs(s[i]) > cutOff && !mask[i]) {
        change = true;
        mask[i] = true;
      }
    }
  }
  // Clean up mask by merging peaks blocks, separated by just a few points(4??).
  let count = 0;
  let prev = 0;
  for (let i = 0; i < s.length; i++) {
    if (!mask[i]) {
      count++;
    } else {
      if (count < maxDistanceToJoin) {
        for (let j = 0; j <= count; j++) {
          mask[prev + j] = true;
        }
      }
      while (mask[++i] && i < s.length);
      prev = i;
      count = 0;
    }
  }

  return mask;
}

function weightedLinearRegression(x, y, w) {
  let sxtw = 0;
  let swx = 0;
  let sw = 0;
  let sxtwy = 0;
  let swy = 0;
  for (let i = 0; i < x.length; i++) {
    sxtw += x[i] * x[i] * w[i];
    swx += x[i] * w[i];
    sw += w[i];
    sxtwy += x[i] * w[i] * y[i];
    swy += w[i] * y[i];
  }

  /* Just to know what is the matrix system that we solve
   let Mx=[[sxtw, swx], [swx, sw]];
   let My=[[sxtwy], [swy]];
  */

  //Mx inverse
  let detMx = sxtw * sw - swx * swx;
  let inMx = [
    [sw / detMx, -swx / detMx],
    [-swx / detMx, sxtw / detMx],
  ];

  return [
    inMx[0][0] * sxtwy + inMx[0][1] * swy,
    inMx[1][0] * sxtwy + inMx[1][1] * swy,
  ];
}

const toRadians = (degree) => (degree * Math.PI) / 180;

const getNegArea = (data) => {
  let area = 0;
  for (let i = 0; i < data.length; i++) {
    if (data[i] < 0) area -= data[i];
  }
  return area;
};

function reimFFT(data, options = {}) {
  const { inverse = false, applyZeroShift = false } = options;

  let { re, im } = data;
  const size = re.length;
  const csize = size << 1;

  let complexArray = new Float64Array(csize);
  for (let i = 0; i < csize; i += 2) {
    complexArray[i] = re[i >>> 1];
    complexArray[i + 1] = im[i >>> 1];
  }

  let fft = new FFT__default['default'](size);
  let output = new Float64Array(csize);
  if (inverse) {
    if (applyZeroShift) complexArray = zeroShift(complexArray, true);
    fft.inverseTransform(output, complexArray);
  } else {
    fft.transform(output, complexArray);
    if (applyZeroShift) output = zeroShift(output);
  }

  let newRe = new Float64Array(size);
  let newIm = new Float64Array(size);
  for (let i = 0; i < csize; i += 2) {
    newRe[i >>> 1] = output[i];
    newIm[i >>> 1] = output[i + 1];
  }

  return { re: newRe, im: newIm };
}

const zeroShift = (data, inverse) => {
  let middle = inverse
    ? Math.ceil(data.length / 2)
    : Math.floor(data.length / 2);
  return xRotate(data, middle);
};

/**
 * This function make a zero filling to re and im part.
 * @param {object} data Object of kind {x:[], re:[], im:[]}.
 * @param {number} totalLength - final number of points
 * @return {SD}
 */
function xreimZeroFilling(data, totalLength) {
  let length = data.x.length;
  if (totalLength === 0 || length === totalLength) return data;

  if (length > totalLength) {
    return {
      x: data.x.slice(0, totalLength),
      re: data.re.slice(0, totalLength),
      im: data.im.slice(0, totalLength),
    };
  }

  const x = data.x;
  const re = data.re;
  const im = data.im;

  const newX = new Float64Array(totalLength);
  const newRE = new Float64Array(totalLength);
  const newIM = new Float64Array(totalLength);

  for (let i = 0; i < length; i++) {
    newX[i] = x[i];
    newRE[i] = re[i];
    newIM[i] = im[i];
  }
  const deltaX = (x[x.length - 1] - x[0]) / (length - 1);
  for (let i = length; i < totalLength; i++) {
    newX[i] = newX[i - 1] + deltaX;
  }

  return {
    x: newX,
    re: newRE,
    im: newIM,
  };
}

/**
 * Sort object of array, x has to be monotone.
 * @param {object} data Object of kind {x:[], re:[], im:[]}.
 * @return {SD}
 */

function xreimSortX(data) {
  const { x, re, im } = data;

  if (x.length !== re.length || x.length !== im.length) {
    throw TypeError('xreimSortX: length of x, re and im must be identical');
  }

  if (x.length < 2 || x[0] < x[1]) return data;

  return {
    x: x.slice(0).reverse(),
    re: re.slice(0).reverse(),
    im: im.slice(0).reverse(),
  };
}

/**
 * Throw an error in no an object of x,y arrays
 * @param {DataXY} [data={}]
 */
function xyCheck(data = {}) {
  if (!isAnyArray__default['default'](data.x) || !isAnyArray__default['default'](data.y)) {
    throw new Error('Data must be an object of x and y arrays');
  }
  if (data.x.length !== data.y.length) {
    throw new Error('The x and y arrays mush have the same length');
  }
}

/**
 * Join x / y values when difference in X is closer than delta.
 * When joining, y values are summed and x values are weighted average
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number|function} [options.delta=1] The range in which the two x values of the spectra must be to be placed on the same line. It may also be a function that allows to change `delta` depending on the X values of the spectrum
 * @return {DataXY} An object with the xyIntegration function
 */

function xyJoinX(data = {}, options = {}) {
  xyCheck(data);
  const { delta = 1 } = options;
  const deltaIsFunction = typeof delta === 'function';
  const x = Array.from(data.x);
  const y = Array.from(data.y);
  if (x.length < 2) {
    return { x, y };
  }
  let position = 0;

  for (let i = 1; i < x.length; i++) {
    let difference = x[i] - x[i - 1];
    let currentDelta = deltaIsFunction ? delta((x[i] + x[i - 1]) / 2) : delta;

    if (difference <= currentDelta) {
      // we join
      if (y[position] !== 0 || y[i] !== 0) {
        x[position] =
          (x[position] * y[position] + x[i] * y[i]) / (y[position] + y[i]);
        y[position] += y[i];
      }
    } else {
      position++;
      x[position] = x[i];
      y[position] = y[i];
    }
  }

  x.length = position + 1;
  y.length = position + 1;
  return { x, y };
}

function getSlots(spectra, options = {}) {
  const { delta = 1 } = options;
  const deltaIsFunction = typeof delta === 'function';

  let possibleXs = Float64Array.from(
    [].concat(...spectra.map((spectrum) => spectrum.x)),
  ).sort();

  if (possibleXs.length < 1) {
    throw new Error('xyArrayMerge can not process empty arrays');
  }

  let currentSlot = {
    from: possibleXs[0],
    to: possibleXs[0],
    average: possibleXs[0],
    sum: possibleXs[0],
    number: 1,
  };
  let slots = [currentSlot];
  for (let i = 1; i < possibleXs.length; i++) {
    let currentDelta = deltaIsFunction ? delta(possibleXs[i]) : delta;
    if (possibleXs[i] - currentSlot.to <= currentDelta) {
      currentSlot.to = possibleXs[i];
      currentSlot.number++;
      currentSlot.sum += possibleXs[i];
      currentSlot.average = currentSlot.sum / currentSlot.number;
    } else {
      currentSlot = {
        from: possibleXs[i],
        to: possibleXs[i],
        average: possibleXs[i],
        sum: possibleXs[i],
        number: 1,
      };
      slots.push(currentSlot);
    }
  }
  return slots;
}

/**
 * Aligns spectra
 * @param {Array<DataXY>} spectra
 * @param {object} [options={}]
 * @param {number|function} [options.delta=1] The range in which the two x values of the spectra must be to be placed on the same line. It may also be a function that allows to change `delta` depending on the X values of the spectrum
 * @returns {object} {x:[], ys[[]]}
 */
function xyArrayAlign(spectra, options = {}) {
  const { delta = 1 } = options;

  // we start by checking that the spectra don't have peaks too close and we simplify them
  spectra = spectra.map((spectrum) => xyJoinX(spectrum, { delta }));

  const slots = getSlots(spectra, options);
  let x = Float64Array.from(slots.map((slot) => slot.average));
  let ys = new Array(spectra.length)
    .fill()
    .map(() => new Float64Array(x.length));

  let positions = new Uint32Array(spectra.length);
  for (let i = 0; i < slots.length; i++) {
    let slot = slots[i];
    for (let j = 0; j < spectra.length; j++) {
      let spectrum = spectra[j];
      while (
        positions[j] < spectrum.x.length &&
        spectrum.x[positions[j]] <= slot.to
      ) {
        ys[j][i] += spectrum.y[positions[j]];
        positions[j]++;
      }
    }
  }

  return { x, ys };
}

/**
 * Merge DataXY
 * We have an array of DataXY and the goal is to merge all the values that are the closest possible
 * @param {Array<DataXY>} spectra
 * @param {object} [options={}]
 * @param {number|function} [options.delta=1] The range in which the two x values of the spectra must be to be placed on the same line. It may also be a function that allows to change `delta` depending on the X values of the spectrum
 */
function xyArrayMerge(spectra, options = {}) {
  const { delta = 1 } = options;
  // we start by checking that the spectra don't have peaks too close and we simplify them
  spectra = spectra.map((spectrum) => xyJoinX(spectrum, { delta }));

  // at first we will calculate the X values (simple mean)
  let slots = getSlots(spectra, options);

  let x = Float64Array.from(slots.map((slot) => slot.average));
  let y = new Float64Array(x.length);

  let positions = new Uint32Array(spectra.length);
  for (let i = 0; i < slots.length; i++) {
    let slot = slots[i];
    for (let j = 0; j < spectra.length; j++) {
      let spectrum = spectra[j];
      while (
        positions[j] < spectrum.x.length &&
        spectrum.x[positions[j]] <= slot.to
      ) {
        y[i] += spectrum.y[positions[j]];
        positions[j]++;
      }
    }
  }

  return { x, y };
}

/**
 * Merge DataXY
 * We have an array of DataXY and the goal is to merge all the values for which the deltaX is small or equal to delta.
 * X values are weighted average
 * @param {Array<DataXY>} spectra
 * @param {object} [options={}]
 * @param {number|function} [options.delta=1] The range in which the two x values of the spectra must be to be placed on the same line. It may also be a function that allows to change `delta` depending on the X values of the spectrum
 * @returns {DataXY}
 */
function xyArrayWeightedMerge(spectra, options = {}) {
  let { delta = 1 } = options;
  if (typeof delta === 'number') {
    let deltaNumber = delta;
    delta = () => deltaNumber;
  }
  spectra = spectra.filter((spectrum) => spectrum.x.length > 0);

  if (spectra.length === 0) return { x: [], y: [] };

  let x = [];
  let y = [];

  const positions = new Array(spectra.length).fill(0);
  const point = { x: 0, y: 0 };

  nextValue(spectra, positions, point);
  let slot = {
    maxX: point.x + delta(point.x),
    sumY: point.y,
    sumXY: point.y * point.x,
  };

  while (spectra.length !== 0) {
    nextValue(spectra, positions, point);
    let sameSlot = point.x <= slot.maxX;
    if (!sameSlot) {
      if (slot.sumY > 0) {
        x.push(slot.sumXY / slot.sumY);
        y.push(slot.sumY);
      }
      slot.sumY = 0;
      slot.sumXY = 0;
    }

    slot.sumY += point.y;
    slot.sumXY += point.x * point.y;
    slot.maxX = point.x + delta(point.x);

    if (spectra.length === 0) {
      if (slot.sumY > 0) {
        x.push(slot.sumXY / slot.sumY);
        y.push(slot.sumY);
      }
    }
  }
  return { x, y };
}

function nextValue(spectra, positions, point) {
  let minIndex = 0;
  let minX = spectra[0].x[positions[0]];

  for (let i = 1; i < spectra.length; i++) {
    let currentX = spectra[i].x[positions[i]];
    if (currentX < minX) {
      minX = currentX;
      minIndex = i;
    }
  }

  point.x = minX;
  point.y = spectra[minIndex].y[positions[minIndex]];

  positions[minIndex]++;

  if (positions[minIndex] === spectra[minIndex].x.length) {
    positions.splice(minIndex, 1);
    spectra.splice(minIndex, 1);
  }
}

function getSlotsToFirst(spectra, options = {}) {
  const { delta = 1 } = options;
  const deltaIsFunction = typeof delta === 'function';

  let firstXs = spectra[0].x;
  let slots = [];
  // we first create the slots based on the first spectrum
  for (let i = 0; i < firstXs.length; i++) {
    let currentDelta = deltaIsFunction ? delta(firstXs[i]) : delta;
    slots.push({
      from: firstXs[i] - currentDelta,
      to: firstXs[i] + currentDelta,
      value: firstXs[i],
    });
  }

  let otherXs = xyArrayWeightedMerge(spectra.slice(1), options).x;
  let currentPosition = 0;
  for (let slot of slots) {
    while (
      otherXs[currentPosition] < slot.to &&
      currentPosition < otherXs.length
    ) {
      if (otherXs[currentPosition] < slot.from) {
        let currentDelta = deltaIsFunction
          ? delta(otherXs[currentPosition])
          : delta;
        slots.push({
          from: otherXs[currentPosition] - currentDelta,
          to: otherXs[currentPosition] + currentDelta,
          value: otherXs[currentPosition],
        });
      }
      currentPosition++;
    }
  }
  for (let i = currentPosition; i < otherXs.length; i++) {
    let currentDelta = deltaIsFunction ? delta(otherXs[i]) : delta;
    slots.push({
      from: otherXs[i] - currentDelta,
      to: otherXs[i] + currentDelta,
      value: otherXs[i],
    });
  }

  slots.sort((a, b) => a.value - b.value);

  // we prevent slots overlap in the first spectrum
  for (let i = 0; i < slots.length - 1; i++) {
    if (slots[i].to > slots[i + 1].from) {
      let middle = (slots[i].value + slots[i + 1].value) / 2;
      slots[i].to = middle;
      slots[i + 1].from = middle;
    }
  }
  return slots;
}

/**
 * We align all the spectra to the first array of X.
 * The alignment is based on the X values of the first spectrum and the `delta` error allowed. If some x values are missing in the first specdtrum we will add them
 * @param {Array<DataXY>} spectra
 * @param {object} [options={}]
 * @param {number|function} [options.delta=1] The range in which the two x values of the spectra must be to be placed on the same line. It may also be a function that allows to change `delta` depending on the X values of the spectrum
 * @returns {object} {x:[], ys[[]]
 */
function xyArrayAlignToFirst(spectra, options = {}) {
  const slots = getSlotsToFirst(spectra, options);
  let x = Float64Array.from(slots.map((slot) => slot.value));
  let ys = new Array(spectra.length)
    .fill()
    .map(() => new Float64Array(x.length));

  let positions = new Uint32Array(spectra.length);
  for (let i = 0; i < slots.length; i++) {
    let slot = slots[i];
    for (let j = 0; j < spectra.length; j++) {
      let spectrum = spectra[j];
      while (
        positions[j] < spectrum.x.length &&
        spectrum.x[positions[j]] < slot.to
      ) {
        ys[j][i] += spectrum.y[positions[j]];
        positions[j]++;
      }
    }
  }

  return { x, ys };
}

/**
 * xyAlign will align data of two spectra by verifying wether x values are in a certain range (`delta`).
 * The two spectra should not have two consecutive x values which difference is
 * smaller than `delta` to achieve good results!
 * @param {DataXY} data1 First spectrum data
 * @param {DataXY} data2 Second spectrum data
 * @param {object} [options={}]
 * @param {number|function} [options.delta=1] The range in which the two x values of the spectra must be to be placed on the same line. It may also be a function that allows to change `delta` depending on the X values of the spectrum
 * @param {boolean} [options.common=true] If `true`, only the data considered as common to both spectra is kept. If `false`, the data y arrays are completed with zeroes where no common values are found
 * @param {string} [options.x='x1'] Defines what x values should be kept (`x1` : spectrum 1 x values, `x2` spectrum 2 x values, `weighted`: weighted average of both spectra x values)
 */
function xyAlign(data1, data2, options = {}) {
  const { delta = 1, common = true, x = 'x1' } = options;

  let result = {
    x: [],
    y1: [],
    y2: [],
  };

  let i = 0;
  let j = 0;

  let length1 = data1.x.length;
  let length2 = data2.x.length;

  while (i < length1 && j < length2) {
    let maxDiff = 0;

    if (typeof delta === 'function') {
      let mean = (data1.x[i] + data2.x[j]) / 2; // is this a good thing to do?
      maxDiff = delta(mean);
    } else {
      maxDiff = delta;
    }

    let difference = data1.x[i] - data2.x[j];

    if (Math.abs(difference) > maxDiff) {
      if (difference > 0) {
        if (!common) {
          result.x.push(data2.x[j]);
          result.y1.push(0);
          result.y2.push(data2.y[j]);
          if (j === length2 - 1) {
            while (i < length1) {
              result.x.push(data1.x[i]);
              result.y1.push(data1.y[i]);
              result.y2.push(0);
              i++;
            }
          }
        }
        // console.log({ i, j }, result);
        j++;
      } else {
        if (!common) {
          result.x.push(data1.x[i]);
          result.y1.push(data1.y[i]);
          result.y2.push(0);
          if (i === length1 - 1) {
            while (j < length2) {
              result.x.push(data2.x[j]);
              result.y1.push(0);
              result.y2.push(data2.y[j]);
              j++;
            }
          }
        }
        // console.log({ i, j }, result);
        i++;
      }
    } else {
      let weightedX =
        (data1.x[i] * data1.y[i] + data2.x[j] * data2.y[j]) /
        (data1.y[i] + data2.y[j]);

      switch (x) {
        case 'x1':
          result.x.push(data1.x[i]);
          break;
        case 'x2':
          result.x.push(data2.x[j]);
          break;
        case 'weighted':
          result.x.push(weightedX);
          break;
        default:
          throw new Error(`Error: Unknown x option value: ${x}`);
      }

      result.y1.push(data1.y[i]);
      result.y2.push(data2.y[j]);

      // console.log({ i, j }, result);

      i++;
      j++;
    }
  }
  return result;
}

/**
 * Finds the max y value in a range and return a {x,y} point
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.from] - First value for xyIntegration in the X scale
 * @param {number} [options.fromIndex=0] - First point for xyIntegration
 * @param {number} [options.to] - Last value for xyIntegration in the X scale
 * @param {number} [options.toIndex=x.length-1] - Last point for xyIntegration
 * @return {object}
 */

function xyMaxYPoint(data = {}, options = {}) {
  xyCheck(data);
  const { x, y } = data;
  if (x.length < 2) return 0;

  const { fromIndex, toIndex } = xGetFromToIndex(x, options);

  let current = { x: x[fromIndex], y: y[fromIndex], index: fromIndex };
  for (let i = fromIndex; i <= toIndex; i++) {
    if (y[i] > current.y) current = { x: x[i], y: y[i], index: i };
  }

  return current;
}

/**
 * Cumulative Distribution Statistics
 * @param {DataXY} [data] array of points {x,y}
 * @returns {object} x0, x25, x50, x75, x100, mode (x for maxY)
 */

const STEPS = [0.25, 0.5, 0.75];

function xyCumulativeDistributionStatistics(data) {
  xyCheck(data);
  const { x, y } = data;
  if (x.length === 0) {
    throw new Error(
      'xyCumulativeDistributionStatistics: Array length must be greater than 0',
    );
  }
  const cumulativeSum = xCumulative(y);
  const maxY = max__default['default'](cumulativeSum);
  for (let i = 0; i < cumulativeSum.length; i++) {
    cumulativeSum[i] /= maxY;
  }

  const result = {};

  // need to find the x values closest to STEPS/100
  result.x0 = x[0];
  result.x100 = x[x.length - 1];

  let currentStep = 0;
  breakPoint: for (let i = 1; i < cumulativeSum.length; i++) {
    while (STEPS[currentStep] < cumulativeSum[i]) {
      result[`x${STEPS[currentStep] * 100}`] =
        x[i - 1] +
        (x[i] - x[i - 1]) *
          ((STEPS[currentStep] - cumulativeSum[i - 1]) /
            (cumulativeSum[i] - cumulativeSum[i - 1]));
      currentStep++;
      if (currentStep === STEPS.length) break breakPoint;
    }
  }
  result.xMode = xyMaxYPoint(data).x;

  let sumXY = 0;
  let sumY = 0;
  for (let i = 0; i < x.length; i++) {
    sumXY += x[i] * y[i];
    sumY += y[i];
  }
  result.xMean = sumXY / sumY;

  return result;
}

/**
 * Filters x,y values to allow strictly growing values in x axis.
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @return {DataXY}
 */
function xyEnsureGrowingX(data = {}) {
  xyCheck(data);
  const x = Array.from(data.x);
  const y = Array.from(data.y);
  let prevX = -Infinity;
  let ansX = [];
  let ansY = [];

  for (let index = 0; index < x.length; index++) {
    if (prevX < x[index]) {
      ansX.push(x[index]);
      ansY.push(y[index]);
      prevX = x[index];
    }
  }
  return { x: ansX, y: ansY };
}

/**
 * Normalize an array of zones:
 * - ensure than from < to
 * - merge overlapping zones
 * @param {Array<Zone>} [zones=[]]
 * @param {object} [options={}]
 * @param {number} [options.from=Number.MIN_VALUE]
 * @param {number} [options.to=Number.MAX_VALUE]
 */

function zonesNormalize(zones = [], options = {}) {
  if (zones.length === 0) return [];
  zones = JSON.parse(JSON.stringify(zones)).map((zone) =>
    zone.from > zone.to ? { from: zone.to, to: zone.from } : zone,
  );
  let { from = Number.NEGATIVE_INFINITY, to = Number.POSITIVE_INFINITY } =
    options;
  if (from > to) {
    [from, to] = [to, from];
  }

  zones = zones.sort((a, b) => {
    if (a.from !== b.from) return a.from - b.from;
    return a.to - b.to;
  });

  zones.forEach((zone) => {
    if (from > zone.from) zone.from = from;
    if (to < zone.to) zone.to = to;
  });

  zones = zones.filter((zone) => zone.from <= zone.to);
  if (zones.length === 0) return [];

  let currentZone = zones[0];
  let result = [currentZone];
  for (let zone of zones) {
    if (zone.from <= currentZone.to) {
      currentZone.to = zone.to;
    } else {
      currentZone = zone;
      result.push(currentZone);
    }
  }
  return result;
}

/**
 * xyExtract zones from a XY data
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {Array} [options.zones=[]]
 * @return {Array} Array of points
 */

function xyExtract(data = {}, options = {}) {
  xyCheck(data);
  const { x, y } = data;
  let { zones } = options;

  zones = zonesNormalize(zones);

  if (!Array.isArray(zones) || zones.length === 0) return data;

  let newX = [];
  let newY = [];

  let currentZone = zones[0];
  let position = 0;
  loop: for (let i = 0; i < x.length; i++) {
    while (currentZone.to < x[i]) {
      position++;
      currentZone = zones[position];
      if (!currentZone) {
        i = x.length;
        break loop;
      }
    }
    if (x[i] >= currentZone.from) {
      newX.push(x[i]);
      newY.push(y[i]);
    }
  }
  return { x: newX, y: newY };
}

/**
 * Filter out all the points for which x <= 0. Useful to display log scale data
 * @param {DataXY} [data={}]
 * @return {{x:[],y:[]}} An object with the filtered data
 */

function xyFilterXPositive(data = {}) {
  xyCheck(data);
  const { x, y } = data;
  const newX = [];
  const newY = [];
  for (let i = 0; i < x.length; i++) {
    if (x[i] > 0) {
      newX.push(x[i]);
      newY.push(y[i]);
    }
  }

  return { x: newX, y: newY };
}

/**
 * Returns the numberMaxPoints points with the bigger y.
 * @param {DataXY} data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {number} numberMaxPoints Number of points to keep
 * @returns {object} The points filtered to keep the `numberMaxPoints` most intense points of the input
 */
function xyGetNMaxY(data, numberMaxPoints) {
  xyCheck(data);
  if (data.x.length <= numberMaxPoints) {
    return data;
  } else {
    let newX = new Array(numberMaxPoints);
    let newY = new Array(numberMaxPoints);

    // slice() is used to make a copy of the array, because sort() is IPM
    let threshold = data.y.slice().sort((a, b) => b - a)[numberMaxPoints - 1];

    let index = 0;
    for (let i = 0; i < data.x.length; i++) {
      if (data.y[i] >= threshold) {
        newX[index] = data.x[i];
        newY[index] = data.y[i];
        index++;
      }
      if (index === numberMaxPoints) {
        return { x: newX, y: newY };
      }
    }
  }
}

/**
 * Order object of array, x has to be monotone.
 * Ensure x is growing
 * @param {DataXY} data Object of kind {x:[], y:[]}.
 * @return {SD}
 */

function xyGrowingX(data) {
  const { x, y } = data;

  if (x.length !== y.length) {
    throw TypeError('sortX: length of x and y must be identical');
  }

  if (x.length < 2 || x[0] < x[1]) return data;

  return {
    x: x.slice(0).reverse(),
    y: y.slice(0).reverse(),
  };
}

/**
 * Generate a X / Y of the xyIntegral
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.from] - First value for xyIntegration in the X scale
 * @param {number} [options.fromIndex=0] - First point for xyIntegration
 * @param {number} [options.to] - Last value for xyIntegration in the X scale
 * @param {number} [options.toIndex=x.length-1] - Last point for xyIntegration
 * @param {boolean} [options.reverse=false] - Integrate from the larger value to the smallest value
 * @return {{x:[],y:[]}} An object with the xyIntegration function
 */

function xyIntegral(data = {}, options = {}) {
  const { reverse = false } = options;
  xyCheck(data);
  const { x, y } = data;
  if (x.length < 2) return 0;

  const { fromIndex, toIndex } = xGetFromToIndex(x, options);

  let xyIntegration = 0;
  let currentxyIntegral;
  if (reverse) {
    currentxyIntegral = { x: [x[toIndex]], y: [0] };
    for (let i = toIndex; i > fromIndex; i--) {
      xyIntegration += ((x[i] - x[i - 1]) * (y[i - 1] + y[i])) / 2;
      currentxyIntegral.x.push(x[i - 1]);
      currentxyIntegral.y.push(xyIntegration);
    }
    currentxyIntegral.x.reverse();
    currentxyIntegral.y.reverse();
  } else {
    currentxyIntegral = { x: [x[fromIndex]], y: [0] };
    for (let i = fromIndex; i < toIndex; i++) {
      xyIntegration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;
      currentxyIntegral.x.push(x[i + 1]);
      currentxyIntegral.y.push(xyIntegration);
    }
  }

  return currentxyIntegral;
}

/**
 * Calculate integration
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.from] - First value for xyIntegration in the X scale
 * @param {number} [options.fromIndex=0] - First point for xyIntegration
 * @param {number} [options.to] - Last value for xyIntegration in the X scale
 * @param {number} [options.toIndex=x.length-1] - Last point for xyIntegration
 * @return {number} xyIntegration value on the specified range
 */

function xyIntegration(data = {}, options = {}) {
  xyCheck(data);
  const { x, y } = data;
  if (x.length < 2) return 0;
  const { fromIndex, toIndex } = xGetFromToIndex(x, options);
  let currentxyIntegration = 0;
  for (let i = fromIndex; i < toIndex; i++) {
    currentxyIntegration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;
  }

  return currentxyIntegration;
}

/**
 * Find the closest maximum going up hill
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.target]
 * @param {number} [options.targetIndex=0]
 * @return {{x,y,xIndex}} An object with the x/y value
 */

function xyMaxClosestYPoint(data, options = {}) {
  xyCheck(data);
  const { x, y } = data;

  let { target, targetIndex } = options;

  if (targetIndex === undefined) {
    if (target !== undefined) {
      targetIndex = xFindClosestIndex(x, target);
    } else {
      targetIndex = 0;
    }
  }

  let previousIndex = Number.MIN_SAFE_INTEGER;
  let currentIndex = targetIndex;

  let xyMaxY = y[targetIndex];

  while (currentIndex !== previousIndex) {
    previousIndex = currentIndex;
    if (currentIndex > 0 && y[currentIndex - 1] > xyMaxY) {
      currentIndex--;
    } else if (currentIndex < x.length - 1 && y[currentIndex + 1] > xyMaxY) {
      currentIndex++;
    }
    xyMaxY = y[currentIndex];
  }
  return {
    x: x[currentIndex],
    y: y[currentIndex],
    index: currentIndex,
  };
}

/**
 * Finds the max value in a zone
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.from] - First value for xyIntegration in the X scale
 * @param {number} [options.fromIndex=0] - First point for xyIntegration
 * @param {number} [options.to] - Last value for xyIntegration in the X scale
 * @param {number} [options.toIndex=x.length-1] - Last point for xyIntegration
 * @return {number} Max y on the specified range
 */

function xyMaxY(data = {}, options = {}) {
  xyCheck(data);
  const { x, y } = data;
  if (x.length < 2) return 0;

  const { fromIndex, toIndex } = xGetFromToIndex(x, options);

  let currentxyMaxY = y[fromIndex];
  for (let i = fromIndex; i <= toIndex; i++) {
    if (y[i] > currentxyMaxY) currentxyMaxY = y[i];
  }

  return currentxyMaxY;
}

/**
 * Finds all the max values
 * If the values are equal the middle
 * of the equal part will be the position of the signal!
 *
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @return {Array} Array of points
 */

function xyMaximaY(data = {}) {
  xyCheck(data);
  const { x, y } = data;
  if (x.length < 3) return [];
  let maxima = [];
  let startEqualIndex = -1;
  for (let i = 1; i < x.length - 1; i++) {
    if (y[i - 1] < y[i] && y[i + 1] < y[i]) {
      maxima.push({ x: x[i], y: y[i], index: i });
    } else if (y[i - 1] < y[i] && y[i + 1] === y[i]) {
      startEqualIndex = i;
    } else if (y[i - 1] === y[i] && y[i + 1] < y[i]) {
      let index = ((i + startEqualIndex) / 2) >> 0;
      maxima.push({ x: x[index], y: y[index], index });
    }
  }
  return maxima;
}

/* *
 * Finds the median x value for an object with properties x and y (arrays of the same length)
 * @param {object} data x should be sorted in increasing order
 * @returns {number} the median of x values
 */

function xyMedian(data) {
  const { x, y } = data;

  let sumY = 0;
  let cumSumY = 0;
  let i;

  if (x.length === 0) {
    return NaN;
  }

  if (x.length === 1) {
    return x[0];
  }

  for (i = 0; i < y.length; i++) {
    sumY += y[i];
  }

  for (i = 0; i < y.length; i++) {
    cumSumY += y[i];
    if (cumSumY > sumY / 2) {
      return x[i];
    } else if (cumSumY === sumY / 2) {
      return 0.5 * (x[i] + x[i + 1]);
    }
  }
}

/**
 * Find the closest minimum going down hill
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.target]
 * @param {number} [options.targetIndex=0]
 * @return {{x,y,xIndex}} An object with the x/y value
 */

function xyMinClosestYPoint(data, options = {}) {
  xyCheck(data);
  const { x, y } = data;

  let { target, targetIndex } = options;

  if (targetIndex === undefined) {
    if (target !== undefined) {
      targetIndex = xFindClosestIndex(x, target);
    } else {
      targetIndex = 0;
    }
  }

  let previousIndex = Number.MIN_SAFE_INTEGER;
  let currentIndex = targetIndex;

  let minY = y[targetIndex];

  while (currentIndex !== previousIndex) {
    previousIndex = currentIndex;
    if (currentIndex > 0 && y[currentIndex - 1] < minY) {
      currentIndex--;
    } else if (currentIndex < x.length - 1 && y[currentIndex + 1] < minY) {
      currentIndex++;
    }
    minY = y[currentIndex];
  }
  return {
    x: x[currentIndex],
    y: y[currentIndex],
    index: currentIndex,
  };
}

/**
 * Finds the max y value in a range and return a {x,y} point
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.from] - First value for xyIntegration in the X scale
 * @param {number} [options.fromIndex=0] - First point for xyIntegration
 * @param {number} [options.to] - Last value for xyIntegration in the X scale
 * @param {number} [options.toIndex=x.length-1] - Last point for xyIntegration
 * @return {object}
 */

function xyMinYPoint(data = {}, options = {}) {
  xyCheck(data);
  const { x, y } = data;
  if (x.length < 2) return 0;

  const { fromIndex, toIndex } = xGetFromToIndex(x, options);

  let current = { x: x[fromIndex], y: y[fromIndex], index: fromIndex };
  for (let i = fromIndex; i <= toIndex; i++) {
    if (y[i] < current.y) current = { x: x[i], y: y[i], index: i };
  }

  return current;
}

/**
 * Finds all the min values
 * If the values are equal the middle
 * of the equal part will be the position of the signal!
 *
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @return {Array} Array of points
 */

function xyMinimaY(data = {}) {
  xyCheck(data);
  const { x, y } = data;
  if (x.length < 3) return [];
  let maxima = [];
  let startEqualIndex = -1;
  for (let i = 1; i < x.length - 1; i++) {
    if (y[i - 1] > y[i] && y[i + 1] > y[i]) {
      maxima.push({ x: x[i], y: y[i], index: i });
    } else if (y[i - 1] > y[i] && y[i + 1] === y[i]) {
      startEqualIndex = i;
    } else if (y[i - 1] === y[i] && y[i + 1] > y[i]) {
      let index = ((i + startEqualIndex) / 2) >> 0;
      maxima.push({ x: x[index], y: y[index], index });
    }
  }
  return maxima;
}

/**
 * Returns an information about a signal
 *
 * We expect ordered data and equidistant X axis
 * You can use the method helper if required:
 * ML.ArrayPoints.uniqueX
 * ML.ArrayPoints.sortX
 * ML.ArrayPoints.equallySpaced
 *
 * @param {object} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.target]
 * @param {number} [options.targetIndex]
 * @return {object} Information about signal
 */

function xyPeakInfo(data = {}, options = {}) {
  xyCheck(data);
  const { x, y } = data;
  if (x.length < 3) return undefined;
  let { targetIndex, target } = options;
  if (targetIndex === undefined) {
    if (target !== undefined) {
      targetIndex = xFindClosestIndex(x, target);
    }
  }

  if (targetIndex === undefined) {
    throw new Error('xyPeakInfo: need to specify target or targetIndex');
  }

  let i = targetIndex;
  let currentDiff = y[i] - y[i + 1];

  let multiplier = currentDiff < 0 ? -1 : 1;
  currentDiff *= multiplier;
  while (i < x.length - 1) {
    i++;
    let newDiff = (y[i] - y[i + 1]) * multiplier;
    if (newDiff < currentDiff) break;
    currentDiff = newDiff;
  }
  let after = { x: x[i], y: y[i] };

  i = targetIndex;
  currentDiff = (y[i] - y[i - 1]) * multiplier;
  while (i > 1) {
    i--;
    let newDiff = (y[i] - y[i - 1]) * multiplier;
    if (newDiff < currentDiff) break;
    currentDiff = newDiff;
  }
  let before = { x: x[i], y: y[i] };

  return {
    inflectionBefore: before,
    inflectionAfter: after,
    extrema: { x: x[targetIndex], y: y[targetIndex] },
    inflectionMiddle: {
      x: (before.x + after.x) / 2,
      y: (before.y + after.y) / 2,
    },
    width: Math.abs(before.x - after.x),
  };
}

/**
 * Find the closest minimum going down hill
 * @param {object} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.target]
 * @param {number} [options.targetIndex=0]
 * @return {{x,y,xIndex}} An object with the x/y value
 */

function xyRealMaxYPoint(data, options = {}) {
  xyCheck(data);
  const { x, y } = data;
  const targetIndex = xGetTargetIndex(x, options);
  // interpolation to a sin() function
  if (
    y[targetIndex - 1] > 0 &&
    y[targetIndex + 1] > 0 &&
    y[targetIndex] >= y[targetIndex - 1] &&
    y[targetIndex] >= y[targetIndex + 1]
  ) {
    let alpha = 20 * Math.log10(y[targetIndex - 1]);
    let beta = 20 * Math.log10(y[targetIndex]);
    let gamma = 20 * Math.log10(y[targetIndex + 1]);
    let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);
    return {
      x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,
      y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,
      index: targetIndex,
    };
  } else {
    return {
      x: x[targetIndex],
      y: y[targetIndex],
      index: targetIndex,
    };
  }
}

function xyRealMinYPoint(data, options = {}) {
  xyCheck(data);
  const { x, y } = data;

  const targetIndex = xGetTargetIndex(x, options);
  // interpolation to a sin() function
  if (
    y[targetIndex - 1] < 0 &&
    y[targetIndex + 1] < 0 &&
    y[targetIndex] <= y[targetIndex - 1] &&
    y[targetIndex] <= y[targetIndex + 1]
  ) {
    let alpha = 20 * Math.log10(-y[targetIndex - 1]);
    let beta = 20 * Math.log10(-y[targetIndex]);
    let gamma = 20 * Math.log10(-y[targetIndex + 1]);
    let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);
    return {
      x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,
      y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,
      index: targetIndex,
    };
  } else {
    return {
      x: x[targetIndex],
      y: y[targetIndex],
      index: targetIndex,
    };
  }
}

/**
 * xyReduce the number of points while keeping visually the same noise. Practical to
 * display many spectra as SVG.
 * SHOULD NOT BE USED FOR DATA PROCESSING !!!
 * You should rather use ml-xy-equally-spaced to make further processing
 * @param {DataXY} [data={}] - Object that contains property x (an ordered increasing array) and y (an array)
 * @param {object} [options={}]
 * @param {number} [options.from=x[0]]
 * @param {number} [options.to=x[x.length-1]]
 * @param {number} [options.nbPoints=4001] Number of points
 * @param {number} [options.zones=[]] Array of zones to keep (from/to object)
 * @param {number} [options.optimize=false] If optimize we may have less than nbPoints at the end
 */

function xyReduce(data, options = {}) {
  xyCheck(data);
  const { x, y } = data;
  let {
    from = x[0],
    to = x[x.length - 1],
    nbPoints = 4001,
    optimize = false,
    zones = [],
  } = options;

  zones = zonesNormalize(zones, { from, to });
  if (zones.length === 0) zones = [{ from, to }]; // we take everything

  // for each zone we should know the first index, the last index and the number of points

  let totalPoints = 0;
  for (let zone of zones) {
    zone.fromIndex = xFindClosestIndex(x, zone.from);
    zone.toIndex = xFindClosestIndex(x, zone.to);
    if (zone.fromIndex > 0 && x[zone.fromIndex] > zone.from) {
      zone.fromIndex--;
    }
    if (zone.toIndex < x.length - 1 && x[zone.toIndex] < zone.to) {
      zone.toIndex++;
    }

    zone.nbPoints = zone.toIndex - zone.fromIndex + 1;
    totalPoints += zone.nbPoints;
  }
  // we calculate the number of points per zone that we should keep
  if (totalPoints > nbPoints) {
    // need to xyReduce number of points
    let ratio = nbPoints / totalPoints;
    let currentTotal = 0;
    for (let i = 0; i < zones.length - 1; i++) {
      const zone = zones[i];
      zone.nbPoints = Math.round(zone.nbPoints * ratio);
      currentTotal += zone.nbPoints;
    }
    zones[zones.length - 1].nbPoints = nbPoints - currentTotal;
  } else {
    let newX = new Float64Array(totalPoints);
    let newY = new Float64Array(totalPoints);
    let index = 0;
    for (let zone of zones) {
      for (let i = zone.fromIndex; i < zone.toIndex + 1; i++) {
        newX[index] = x[i];
        newY[index] = y[i];
        index++;
      }
    }
    return {
      x: newX,
      y: newY,
    };
  }

  let newX = [];
  let newY = [];
  for (let zone of zones) {
    if (!zone.nbPoints) continue;
    appendFromTo(zone.fromIndex, zone.toIndex, zone.nbPoints);
  }
  return { x: newX, y: newY };

  function appendFromTo(fromIndex, toIndex, zoneNbPoints) {
    if (zoneNbPoints === 1) {
      newX.push(x[Math.round((toIndex - fromIndex) / 2)]);
      newY.push(y[Math.round((toIndex - fromIndex) / 2)]);
      return;
    }
    if (zoneNbPoints === 2) {
      newX.push(x[fromIndex], x[toIndex]);
      newY.push(y[fromIndex], y[toIndex]);
      return;
    }
    newX.push(x[fromIndex]);
    newY.push(y[fromIndex]);
    let minY = Number.MAX_VALUE;
    let xyMaxY = Number.MIN_VALUE;
    if (zoneNbPoints % 2 === 0) {
      zoneNbPoints = zoneNbPoints / 2 + 1;
    } else {
      zoneNbPoints = (zoneNbPoints - 1) / 2 + 1;
    }

    // we will need to make some kind of min / max because there are too many points
    // we will always keep the first point and the last point
    let slot = (x[toIndex] - x[fromIndex]) / (zoneNbPoints - 1);
    let currentX = x[fromIndex] + slot;
    let first = true;
    for (let i = fromIndex + 1; i <= toIndex; i++) {
      if (first) {
        minY = y[i];
        xyMaxY = y[i];
        first = false;
      } else {
        if (y[i] < minY) minY = y[i];
        if (y[i] > xyMaxY) xyMaxY = y[i];
      }
      if (x[i] >= currentX || i === toIndex) {
        if (optimize) {
          if (minY > newY[newX.length - 1]) ; else if (xyMaxY < newY[newX.length - 1]) {
            // we can skip the intermediate value
            xyMaxY = minY;
          } else {
            newX.push(currentX - slot / 2);
            newY.push(minY);
          }
        } else {
          newX.push(currentX - slot / 2);
          newY.push(minY);
        }

        newX.push(currentX);
        newY.push(xyMaxY);

        currentX += slot;
        first = true;
      }
    }
  }
}

/**
 * This function calculates a rolling average
 *
 * This methods will recalculate the x values by using xRollingAverage
 * @param {ArrayPoints} [points] array of points {x,y}
 * @param {object} [options={}]
 * @param {number} [options.window=5] rolling window
 * @param {function} [fct] callback function that from an array returns a value.
 * @param {string} [options.padding.size=0] none, value, circular, duplicate
 * @param {string} [options.padding.algorithm='value'] none, value, circular, duplicate
 * @param {number} [options.padding.value=0] value to use for padding (if algorithm='value')
 * @return {Array<Number>}
 */
function xyRolling(points, fct, options = {}) {
  let { x, y } = points;

  y = xRolling(y, fct, options);

  if (x.length !== y.length) {
    x = xRollingAverage(x, options);
  }

  return { x, y };
}

/**
 *
 * @param {DataXY} [data] array of points {x,y}
 * @returns {DataPoints}
 */
function xyToXYObject(data) {
  xyCheck(data);
  const { x, y } = data;
  let objectArray = [];
  for (let i = 0; i < x.length; i++) {
    objectArray.push({ x: x[i], y: y[i] });
  }
  return objectArray;
}

/**
 * Convert a DataXY to an array of array containing x,y
 * @param {DataXY} [data] array of points {x,y}
 * @returns {Array<Array<number,number>>}
 */
function xyToXYArray(data) {
  xyCheck(data);
  const { x, y } = data;
  let objectArray = [];
  for (let i = 0; i < x.length; i++) {
    objectArray.push([x[i], y[i]]);
  }

  return objectArray;
}

/**
 * Calibrates the data based on a range and means of peaks in this range
 * Based on a range we will make a peak picking using global spectra deconvolution
 * The selected nbPeaks will then be taken into account to calculate an average X value.
 * The difference between the targetX and the averageX value will be returned
 * @param {DataXY} [data] array of points {x,y}
 * @param {Object} [range={}]
 * @param {number} [range.from] - Beginning of the range where the interest signal is localed
 * @param {number} [range.to] - End of the range where the interest signal is localed
 * @param {Object} [options={}]
 * @param {number} [options.nbPeaks=1] Number of peaks to consider to calculate mean (sorted by height)
 * @param {number} [options.targetX=0] Expected value for the mean of the peaks position
 * @param {number} [options.gsd={}] GSD options. You may check options here: http://mljs.github.io/global-spectral-deconvolution/#gsd
 * @param {number} [options.gsd.minMaxRatio=0.2] - GSD Threshold to determine if a given peak should be considered as a noise.
 * @returns {number} difference between targetX and currentX
 */

function xyCalibrate(data, range = {}, options = {}) {
  const {
    targetX = 0,
    nbPeaks = 1,
    gsd: gsdOptions = {
      minMaxRatio: 0.1,
      realTopDetection: true,
      smoothY: true,
      sgOptions: {
        windowSize: 7,
        polynomial: 3,
      },
    },
  } = options;
  let { from, to } = range;
  if (from === undefined || to === undefined) return 0;

  const fromIndex = xFindClosestIndex(data.x, from);
  const toIndex = xFindClosestIndex(data.x, to);
  const sliceddata = {
    x: data.x.slice(fromIndex, toIndex),
    y: data.y.slice(fromIndex, toIndex),
  };

  let peaks = mlGsd.gsd(sliceddata, gsdOptions)
    .sort((a, b) => b.y - a.y)
    .slice(0, nbPeaks);

  if (peaks.length === 0) return 0;

  const middle = mean__default['default'](peaks.map((peak) => peak.x));

  return targetX - middle;
}

/**
import { xIsMonotone } from '../x/xIsMonotone';
 * This function performs a quick sort of the x array while transforming the y array to preserve the coordinates.
 * @param {DataXY} [data] Object that contains property x (Array) and y (Array)
 */
function xySortX(data) {
  const { x, y } = data;

  // no need to sort if it is already sorted
  if (xIsMonotone(x) && x.length > 1) {
    if (x[0] < x[1]) {
      return {
        x: Float64Array.from(x),
        y: Float64Array.from(y),
      };
    } else {
      return {
        x: Float64Array.from(x).reverse(),
        y: Float64Array.from(y).reverse(),
      };
    }
  }

  let xyObject = x
    .map((val, index) => ({
      x: val,
      y: y[index],
    }))
    .sort((a, b) => a.x - b.x);

  let response = {
    x: new Float64Array(x.length),
    y: new Float64Array(y.length),
  };
  for (let i = 0; i < x.length; i++) {
    response.x[i] = xyObject[i].x;
    response.y[i] = xyObject[i].y;
  }

  return response;
}

/**
 * Ensure x values are unique
 * @param {DataXY} [data] Object that contains property x (Array) and y (Array)
 * @param {Object} [options={}] Object containing a property algorithm (can be 'sum' or 'average', the latter being the default value), and a property isSorted (boolean indicating if the x-array is sorted).
 * @param {string} [options.algorithm='average'] either 'average' or 'sum'
 * @param {boolean} [options.isSorted=true] if false the DataXY has to be sorted first
 * @returns {DataXY}
 */
function xyUniqueX(data, options = {}) {
  xyCheck(data);

  const { algorithm = 'average', isSorted = true } = options;

  if (!isSorted) {
    data = xySortX(data);
  }

  switch (algorithm) {
    case 'average':
      return average(data);
    case 'sum':
      return sum(data);
    default:
      throw new Error(`xyUniqueX: unknown algorithm: ${algorithm}`);
  }
}

function average(data) {
  let x = [];
  let y = [];
  let cumulativeY = data.y[0];
  let divider = 1;
  for (let i = 1; i < data.x.length; i++) {
    if (!(data.x[i] === data.x[i - 1])) {
      x.push(data.x[i - 1]);
      y.push(cumulativeY / divider);
      cumulativeY = 0;
      divider = 0;
    }
    cumulativeY += data.y[i];
    divider++;
  }
  x.push(data.x[data.x.length - 1]);
  y.push(cumulativeY / divider);
  return { x, y };
}

function sum(data) {
  let x = [];
  let y = [];
  let cumulativeY = data.y[0];
  for (let i = 1; i < data.x.length; i++) {
    if (!(data.x[i] === data.x[i - 1])) {
      x.push(data.x[i - 1]);
      y.push(cumulativeY);
      cumulativeY = 0;
    }
    cumulativeY += data.y[i];
  }
  x.push(data.x[data.x.length - 1]);
  y.push(cumulativeY);
  return { x, y };
}

/**
 * Throw an error in no an object of x,y arrays
 * @param {ArrayPoints} [points=[]]
 */
function xyObjectCheck(points = []) {
  if (!Array.isArray(points)) {
    throw new Error('ArrayPoints must be an array of {x,y} object');
  }
  if (
    points.length > 0 &&
    (points[0].x === undefined || points[0].y === undefined)
  ) {
    throw new Error('ArrayPoints must be an array of {x,y} object');
  }
}

/**
 * Finds the max x value and return a {x,y,index} point
 * @param {DataXY} [points=[]] - Object that contains property x (an ordered increasing array) and y (an array)
 * @return {object}
 */

function xyObjectMaxXPoint(points = []) {
  xyObjectCheck(points);

  if (points.length < 1) return {};

  let current = {
    x: points[0].x,
    y: points[0].y,
    index: 0,
  };

  for (let i = 1; i < points.length; i++) {
    if (points[i].x > current.x) {
      current = {
        x: points[i].x,
        y: points[i].y,
        index: i,
      };
    }
  }

  return current;
}

/**
 * Finds the min x value and return a {x,y,index} point
 * @param {DataXY} [points=[]] - Object that contains property x (an ordered increasing array) and y (an array)
 * @return {object}
 */

function xyObjectMinXPoint(points = []) {
  xyObjectCheck(points);

  if (points.length < 1) return {};

  let current = {
    x: points[0].x,
    y: points[0].y,
    index: 0,
  };

  for (let i = 1; i < points.length; i++) {
    if (points[i].x < current.x) {
      current = {
        x: points[i].x,
        y: points[i].y,
        index: i,
      };
    }
  }

  return current;
}

/**
 * Filter the array by taking the higher points (max y value) and only
 * keep one per slot.
 * There are 2 different slots, the smallest one will have the
 * new property `close` to true
 * @param {array} points - array of all the points
 * @param {object} [options={}]
 * @param {number} [options.from] - min X value of the window to consider
 * @param {number} [options.to] - max X value of the window to consider
 * @param {number} [options.limit=20] - max number of points
 * @param {number} [options.threshold=0.01] - minimal intensity compare to more intense point
 * @param {number} [options.numberSlots=10] - define the number of slots and indirectly the slot width
 * @param {number} [options.numberCloseSlots=50]
 * @returns {array} - copy of points with 'close' property
 */

function xyObjectBestPoints(points, options = {}) {
  const {
    from = xyObjectMinXPoint(points).x,
    to = xyObjectMaxXPoint(points).x,
    limit = 20,
    threshold = 0.01,
    numberCloseSlots = 50,
    numberSlots = 10,
  } = options;
  let slot = (to - from) / numberSlots;
  let closeSlot = (to - from) / numberCloseSlots;
  let selected = points
    .filter((point) => point.x >= from && point.x <= to)
    .map((point) => {
      return {
        point,
        monoisotopic: false,
      };
    });

  selected = selected.sort((a, b) => {
    if (a.monoisotopic && !b.monoisotopic) return -1;
    if (b.monoisotopic && !a.monoisotopic) return 1;
    return b.point.y - a.point.y;
  });

  let toReturn = [];
  if (selected.length === 0) return [];
  let minY = selected[0].point.y * threshold;
  peakLoop: for (let item of selected) {
    if (item.point.y < minY) {
      if (item.monoisotopic) {
        continue;
      } else {
        break;
      }
    }
    let close = false;
    for (let existing of toReturn) {
      if (Math.abs(existing.x - item.point.x) < closeSlot) {
        continue peakLoop;
      }
      if (Math.abs(existing.x - item.point.x) < slot) {
        close = true;
      }
    }
    let newPeak = JSON.parse(JSON.stringify(item.point));
    newPeak.close = close;
    toReturn.push(newPeak);
    if (toReturn.length === limit) break;
  }
  return toReturn.sort((a, b) => a.x - b.x);
}

/**
 *
 * @param {ArrayPoints} [points] array of growing points {x,y}
 * @param {object} [options={}]
 * @param {object} [xError=Number.EPSILON] limit to join the data
 */
function xyObjectJoinX(points, options = {}) {
  const { xError = Number.EPSILON } = options;

  // when we join we will use the center of mass
  let result = [];
  let current = {
    x: Number.MIN_SAFE_INTEGER,
    y: 0,
  };
  for (let point of points) {
    if (point.x - current.x <= xError) {
      // weighted sum
      if (current.y !== 0 || point.y !== 0) {
        current.x =
          (point.y / (current.y + point.y)) * (point.x - current.x) + current.x;
        current.y += point.y;
      }
    } else {
      current = {
        x: point.x,
        y: point.y,
      };
      result.push(current);
    }
  }
  return result;
}

/**
 * Finds the max y value and return a {x,y,index} point
 * @param {DataXY} [points=[]] - Object that contains property x (an ordered increasing array) and y (an array)
 * @return {object}
 */

function xyObjectMaxYPoint(points = []) {
  xyObjectCheck(points);

  if (points.length < 1) return {};

  let current = {
    x: points[0].x,
    y: points[0].y,
    index: 0,
  };

  for (let i = 1; i < points.length; i++) {
    if (points[i].y > current.y) {
      current = {
        x: points[i].x,
        y: points[i].y,
        index: i,
      };
    }
  }

  return current;
}

/**
 * Finds the min y value and return a {x,y,index} point
 * @param {DataXY} [points=[]] - Object that contains property x (an ordered increasing array) and y (an array)
 * @return {object}
 */

function xyObjectMinYPoint(points = []) {
  xyObjectCheck(points);

  if (points.length < 1) return {};

  let current = {
    x: points[0].x,
    y: points[0].y,
    index: 0,
  };

  for (let i = 1; i < points.length; i++) {
    if (points[i].y < current.y) {
      current = {
        x: points[i].x,
        y: points[i].y,
        index: i,
      };
    }
  }

  return current;
}

/**
 *
 * @param {ArrayPoints} [points] array of growing points {x,y}
 * @param {object} [options={}]
 * @param {object} [slotWidth=1] limit to join the data
 */
function xyObjectSlotX(points, options = {}) {
  const { slotWidth = 1 } = options;
  const halfSlot = slotWidth / 2;

  // when we join we will use the center of mass
  let result = [];
  let current = {
    x: Number.MIN_VALUE,
    y: 0,
  };
  for (let point of points) {
    let slot = point.x - ((point.x + halfSlot) % slotWidth) + halfSlot;
    if (Math.abs(current.x - slot) > Number.EPSILON) {
      current = {
        x: slot,
        y: 0,
      };
      result.push(current);
    }
    current.y += point.y;
  }
  return result;
}

/**
 * Sorts an array of points
 * @param {ArrayPoints} [points] array of points {x,y}
 */

function xyObjectSortX(points) {
  return points.sort((a, b) => a.x - b.x);
}

/**
 *
 * @param {ArrayPoints} [points] array of points {x,y}
 */
function xyObjectToXY(points) {
  return {
    x: points.map((entry) => entry.x),
    y: points.map((entry) => entry.y),
  };
}

function zoneToX(zone, size) {
  const { from, to } = zone;
  let array = new Float64Array(size);
  let step = (to - from) / (size - 1);
  for (let i = 0; i < size; i++) {
    array[i] = from + step * i;
  }
  return array;
}

/**
 * Center mean of columns
 * @param {Array<Array<Number>>} [matrix] - matrix [rows][cols].
 */
function matrixCenterZMean(matrix) {
  const nbRows = matrix.length;
  const nbColumns = matrix[0].length;
  const newMatrix = new Array(nbRows);
  for (let row = 0; row < nbRows; row++) {
    newMatrix[row] = new Float64Array(nbColumns);
  }
  for (let column = 0; column < nbColumns; column++) {
    let mean = 0;
    for (let row = 0; row < nbRows; row++) {
      mean += matrix[row][column];
    }
    mean /= nbRows;
    for (let row = 0; row < nbRows; row++) {
      newMatrix[row][column] = matrix[row][column] - mean;
    }
  }
  return newMatrix;
}

/**
 * Get min and max of the absolute values of Z
 * @param {Array<Array<Number>>} [matrix] - matrix [rows][cols].
 *
 */
function matrixMinMaxAbsoluteZ(matrix) {
  if (matrix.length === 0 || matrix[0].length === 0) {
    return { min: undefined, max: undefined };
  }
  const nbRows = matrix.length;
  const nbColumns = matrix[0].length;

  let min = Number.POSITIVE_INFINITY;
  let max = Number.NEGATIVE_INFINITY;

  for (let column = 0; column < nbColumns; column++) {
    for (let row = 0; row < nbRows; row++) {
      let value = matrix[row][column];
      if (value < 0) value *= -1;
      if (value < min) min = value;
      if (value > max) max = value;
    }
  }

  return { min, max };
}

/**
 * Get min and max Z
 * @param {Array<Array<Number>>} [matrix] - matrix [rows][cols].
 *
 */
function matrixMinMaxZ(matrix) {
  if (matrix.length === 0 || matrix[0].length === 0) {
    return { min: undefined, max: undefined };
  }
  const nbRows = matrix.length;
  const nbColumns = matrix[0].length;

  let min = matrix[0][0];
  let max = matrix[0][0];

  for (let column = 0; column < nbColumns; column++) {
    for (let row = 0; row < nbRows; row++) {
      if (matrix[row][column] < min) min = matrix[row][column];
      if (matrix[row][column] > max) max = matrix[row][column];
    }
  }

  return { min, max };
}

/**
import { matrixMinMaxZ } from './matrixMinMaxZ';
import { xHistogram } from '../x/xHistogram';
import { matrixMinMaxAbsoluteZ } from './matrixMinMaxAbsoluteZ';
 * Calculates an histogram of defined number of slots
 * @param {Array<Array<Number>>} [matrix] - matrix [rows][cols].
 * @param {number} [options.nbSlots=256] Number of slots
 * @param {number} [options.min=minValue] Minimum value to calculate used to calculate slot size
 * @param {number} [options.max=maxValue] Maximal value to calculate used to calculate slot size
 * @param {number} [options.logBaseX] We can first apply a log on x axi
 * @param {number} [options.logBaseY] We can apply a log on the resulting histogra
 * @param {boolean} [options.absolute] Take the absolute value
 * @param {number} [options.centerX=true] Center the X value. We will enlarge the first and
 * @return {DataXY} {x,y} of the histogram
 *
 */

function matrixHistogram(matrix, options = {}) {
  const { logBaseY, logBaseX, absolute } = options;
  options = JSON.parse(JSON.stringify(options));
  delete options.logBaseY;
  if (matrix.length === 0 || matrix[0].length === 0) {
    throw new Error(
      'matrixHistogram: matrix should have at least one column and one row',
    );
  }

  if (options.min === undefined || options.max === undefined) {
    const minMax = absolute
      ? matrixMinMaxAbsoluteZ(matrix)
      : matrixMinMaxZ(matrix);
    if (options.min === undefined) {
      options.min = logBaseX
        ? Math.log(minMax.min) / Math.log(logBaseX)
        : minMax.min;
    }
    if (options.max === undefined) {
      options.max = logBaseX
        ? Math.log(minMax.max) / Math.log(logBaseX)
        : minMax.max;
    }
  }

  let histogram = xHistogram(matrix[0], options);
  options.histogram = histogram;

  const nbRows = matrix.length;
  for (let row = 1; row < nbRows; row++) {
    xHistogram(matrix[row], options);
  }

  const y = histogram.y;
  if (logBaseY) {
    const logOfBase = Math.log10(logBaseY);
    for (let i = 0; i < y.length; i++) {
      y[i] = Math.log10(y[i] + 1) / logOfBase;
    }
  }

  return histogram;
}

/**
 * Performs a Probabilistic quotient normalization (PQN) over the dataset to account dilution based in median spectrum.
 * Dieterle, F., Ross, A., Schlotterbeck, G., & Senn, H. (2006). Probabilistic quotient normalization as robust method to account for dilution of complex biological mixtures. Application in 1H NMR metabonomics. Analytical chemistry, 78(13), 4281-4290.
 * DOI: 10.1021/ac051632c
 * @param {Array<Array<Number>>} [matrix] - matrix [rows][cols].
 * @param {Object} [options={}]
 * @param {number} [options.max=100] - Normalization integral constant.
 * @return {Object} { data, medianOfQuotients }.
 * data: Normalized dataset.
 * medianOfQuotients: The median of quotients of each variables.
 */
function matrixPQN(matrix, options = {}) {
  const { max = 100 } = options;
  matrix = new mlMatrix.Matrix(matrix);
  for (let i = 0; i < matrix.rows; i++) {
    const normalizationFactor = matrix.getRowVector(i).norm() / max;
    const row = matrix.getRowVector(i).div(normalizationFactor);
    matrix.setRow(i, row);
  }

  let referenceSpectrum = [];
  for (let i = 0; i < matrix.columns; i++) {
    const currentVariable = matrix.getColumn(i);
    referenceSpectrum.push(median__default['default'](currentVariable));
  }

  let medianOfQuotients = [];
  for (let i = 0; i < matrix.columns; i++) {
    let quotients = matrix.getColumnVector(i).div(referenceSpectrum[i]);
    medianOfQuotients.push(median__default['default'](quotients.getColumn(0)));
  }

  for (let i = 0; i < matrix.rows; i++) {
    matrix.mulRow(i, 1 / medianOfQuotients[i]);
  }

  return {
    data: matrix.to2DArray(),
    medianOfQuotients: medianOfQuotients,
  };
}

/**
 * Rescale columns
 * @param {Array<Array<Number>>} [matrix] - matrix [rows][cols].
 * @param {object} [options={}]
 * @param {object} [options.min=0]
 * @param {object} [options.max=1]
 *
 */
function matrixZRescale(matrix, options = {}) {
  const { min = 0, max = 1 } = options;
  const nbRows = matrix.length;
  const nbColumns = matrix[0].length;
  const newMatrix = new Array(nbRows);
  for (let row = 0; row < nbRows; row++) {
    newMatrix[row] = new Float64Array(nbColumns);
  }
  for (let column = 0; column < nbColumns; column++) {
    let currentMin = matrix[0][column];
    let currentMax = matrix[0][column];
    for (let row = 1; row < nbRows; row++) {
      if (matrix[row][column] < currentMin) currentMin = matrix[row][column];
      if (matrix[row][column] > currentMax) currentMax = matrix[row][column];
    }

    const factor = (max - min) / (currentMax - currentMin);

    for (let row = 0; row < nbRows; row++) {
      newMatrix[row][column] =
        (matrix[row][column] - currentMin) * factor + min;
    }
  }
  return newMatrix;
}

/**
 * Create an array with sequential numbers between from and to of length
 * @param {number} [options.from=0]
 * @param {number} [options.to=1]
 * @param {number} [options.length=1001]
 */
function createSequentialArray(options = {}) {
  const { from = 0, to = 1, length = 1000 } = options;
  const array = new Float64Array(length);
  let step = (to - from) / (array.length - 1);
  for (let i = 0; i < array.length; i++) {
    array[i] = from + step * i;
  }
  return array;
}

exports.createSequentialArray = createSequentialArray;
exports.matrixCenterZMean = matrixCenterZMean;
exports.matrixHistogram = matrixHistogram;
exports.matrixMinMaxAbsoluteZ = matrixMinMaxAbsoluteZ;
exports.matrixMinMaxZ = matrixMinMaxZ;
exports.matrixPQN = matrixPQN;
exports.matrixZRescale = matrixZRescale;
exports.reimAbsolute = reimAbsolute;
exports.reimAutoPhaseCorrection = reimAutoPhaseCorrection;
exports.reimFFT = reimFFT;
exports.reimPhaseCorrection = reimPhaseCorrection;
exports.xAbsolute = xAbsolute;
exports.xAbsoluteMedian = xAbsoluteMedian;
exports.xAdd = xAdd;
exports.xAutoCorrelation = xAutoCorrelation;
exports.xBoxPlot = xBoxPlot;
exports.xCorrelation = xCorrelation;
exports.xCrossCorrelation = xCrossCorrelation;
exports.xCumulative = xCumulative;
exports.xDivide = xDivide;
exports.xDotProduct = xDotProduct;
exports.xFindClosestIndex = xFindClosestIndex;
exports.xGetFromToIndex = xGetFromToIndex;
exports.xGetTargetIndex = xGetTargetIndex;
exports.xHistogram = xHistogram;
exports.xIsMonotone = xIsMonotone;
exports.xMaxIndex = xMaxIndex;
exports.xMaxValue = xMaxValue;
exports.xMean = xMean;
exports.xMeanAbsoluteError = xMeanAbsoluteError;
exports.xMeanSquaredError = xMeanSquaredError;
exports.xMinIndex = xMinIndex;
exports.xMinMaxValues = xMinMaxValues;
exports.xMinValue = xMinValue;
exports.xMultiply = xMultiply;
exports.xNoiseSanPlot = xNoiseSanPlot;
exports.xNorm = xNorm;
exports.xPadding = xPadding;
exports.xParetoNormalization = xParetoNormalization;
exports.xRolling = xRolling;
exports.xRollingAverage = xRollingAverage;
exports.xRollingMax = xRollingMax;
exports.xRollingMedian = xRollingMedian;
exports.xRollingMin = xRollingMin;
exports.xRotate = xRotate;
exports.xSubtract = xSubtract;
exports.xSum = xSum;
exports.xUniqueSorted = xUniqueSorted;
exports.xreimSortX = xreimSortX;
exports.xreimZeroFilling = xreimZeroFilling;
exports.xyAlign = xyAlign;
exports.xyArrayAlign = xyArrayAlign;
exports.xyArrayAlignToFirst = xyArrayAlignToFirst;
exports.xyArrayMerge = xyArrayMerge;
exports.xyArrayWeightedMerge = xyArrayWeightedMerge;
exports.xyCalibrate = xyCalibrate;
exports.xyCheck = xyCheck;
exports.xyCumulativeDistributionStatistics = xyCumulativeDistributionStatistics;
exports.xyEnsureGrowingX = xyEnsureGrowingX;
exports.xyExtract = xyExtract;
exports.xyFilterXPositive = xyFilterXPositive;
exports.xyGetNMaxY = xyGetNMaxY;
exports.xyGrowingX = xyGrowingX;
exports.xyIntegral = xyIntegral;
exports.xyIntegration = xyIntegration;
exports.xyJoinX = xyJoinX;
exports.xyMaxClosestYPoint = xyMaxClosestYPoint;
exports.xyMaxY = xyMaxY;
exports.xyMaxYPoint = xyMaxYPoint;
exports.xyMaximaY = xyMaximaY;
exports.xyMedian = xyMedian;
exports.xyMinClosestYPoint = xyMinClosestYPoint;
exports.xyMinYPoint = xyMinYPoint;
exports.xyMinimaY = xyMinimaY;
exports.xyObjectBestPoints = xyObjectBestPoints;
exports.xyObjectJoinX = xyObjectJoinX;
exports.xyObjectMaxXPoint = xyObjectMaxXPoint;
exports.xyObjectMaxYPoint = xyObjectMaxYPoint;
exports.xyObjectMinXPoint = xyObjectMinXPoint;
exports.xyObjectMinYPoint = xyObjectMinYPoint;
exports.xyObjectSlotX = xyObjectSlotX;
exports.xyObjectSortX = xyObjectSortX;
exports.xyObjectToXY = xyObjectToXY;
exports.xyPeakInfo = xyPeakInfo;
exports.xyRealMaxYPoint = xyRealMaxYPoint;
exports.xyRealMinYPoint = xyRealMinYPoint;
exports.xyReduce = xyReduce;
exports.xyRolling = xyRolling;
exports.xySortX = xySortX;
exports.xyToXYArray = xyToXYArray;
exports.xyToXYObject = xyToXYObject;
exports.xyUniqueX = xyUniqueX;
exports.zoneToX = zoneToX;
exports.zonesNormalize = zonesNormalize;
