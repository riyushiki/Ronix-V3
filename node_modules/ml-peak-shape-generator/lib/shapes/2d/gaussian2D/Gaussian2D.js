"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSurface = exports.getFactor = exports.getData = exports.fct = exports.Gaussian2D = exports.fwhmToWidth = exports.widthToFWHM = void 0;
const constants_1 = require("../../../util/constants");
const erfinv_1 = __importDefault(require("../../../util/erfinv"));
const Gaussian_1 = require("../../1d/gaussian/Gaussian");
const Shape2D_1 = require("../Shape2D");
var Gaussian_2 = require("../../1d/gaussian/Gaussian");
Object.defineProperty(exports, "widthToFWHM", { enumerable: true, get: function () { return Gaussian_2.widthToFWHM; } });
Object.defineProperty(exports, "fwhmToWidth", { enumerable: true, get: function () { return Gaussian_2.fwhmToWidth; } });
class Gaussian2D extends Shape2D_1.Shape2D {
    constructor(options = {}) {
        super();
        let { fwhm = 50, sd, height } = options;
        fwhm = ensureFWHM2D(fwhm, sd);
        this.fwhmX = fwhm.x;
        this.fwhmY = fwhm.y;
        this.height =
            height === undefined
                ? -constants_1.GAUSSIAN_EXP_FACTOR / Math.PI / this.fwhmY / this.fwhmX
                : height;
    }
    fct(x, y) {
        return fct(x, y, this.fwhmX, this.fwhmY);
    }
    getData(options = {}) {
        const { factor, length } = options;
        return getData({
            fwhm: { x: this.fwhmY, y: this.fwhmY },
            height: this.height,
            factor,
            length,
        });
    }
    getFactor(surface) {
        return getFactor(surface);
    }
    getSurface() {
        return getSurface({
            fwhm: { x: this.fwhmY, y: this.fwhmY },
            height: this.height,
        });
    }
    widthToFWHM(width) {
        return Gaussian_1.widthToFWHM(width);
    }
    fwhmToWidth(fwhm) {
        return Gaussian_1.fwhmToWidth(fwhm);
    }
    set fwhm(fwhm) {
        fwhm = ensureXYNumber(fwhm);
        this.fwhmX = fwhm.x;
        this.fwhmY = fwhm.y;
    }
}
exports.Gaussian2D = Gaussian2D;
/**
 * Return a parameterized function of a Gaussian2D shape (see README for equation).
 * @param x - x value to calculate.
 * @param y - y value to calculate.
 * @param fwhmX - full width half maximum in the x axis.
 * @param fwhmY - full width half maximum in the y axis.
 * @returns - the z value of bi-dimensional gaussian with the current parameters.
 */
function fct(x, y, xFWHM, yFWHM) {
    return Math.exp(constants_1.GAUSSIAN_EXP_FACTOR * (Math.pow(x / xFWHM, 2) + Math.pow(y / yFWHM, 2)));
}
exports.fct = fct;
/**
 * Calculate the intensity matrix of a gaussian shape.
 * @returns z values.
 */
function getData(options = {}) {
    let { fwhm = 50, factor = getFactor(), height, sd, length = { x: 0, y: 0 }, } = options;
    fwhm = ensureFWHM2D(fwhm, sd);
    factor = ensureXYNumber(factor);
    length = ensureXYNumber(length);
    if (!height) {
        height = -constants_1.GAUSSIAN_EXP_FACTOR / Math.PI / fwhm.y / fwhm.x;
    }
    for (const axis of ['x', 'y']) {
        if (!length[axis]) {
            length[axis] = Math.min(Math.ceil(fwhm[axis] * factor[axis]), Math.pow(2, 25) - 1);
            if (length[axis] % 2 === 0)
                length[axis]++;
        }
    }
    const xCenter = (length.x - 1) / 2;
    const yCenter = (length.y - 1) / 2;
    const data = new Array(length.x);
    for (let i = 0; i < length.x; i++) {
        data[i] = new Float64Array(length.y);
    }
    for (let i = 0; i < length.x; i++) {
        for (let j = 0; j < length.y; j++) {
            data[i][j] = fct(i - xCenter, j - yCenter, fwhm.x, fwhm.y) * height;
        }
    }
    return data;
}
exports.getData = getData;
/**
 * Calculate the number of times FWHM allows to reach a specific surface coverage.
 * @param [surface=0.9999] Expected volume to be covered.
 * @returns
 */
function getFactor(surface = 0.9999) {
    return Math.sqrt(2) * erfinv_1.default(surface);
}
exports.getFactor = getFactor;
/**
 * Calculate the surface of gaussian shape.
 * @returns The surface of the specific shape and parameters.
 */
function getSurface(options = {}) {
    let { fwhm = 50, height = 1 } = options;
    if (typeof fwhm !== 'object')
        fwhm = { x: fwhm, y: fwhm };
    return (height * Math.PI * fwhm.y * fwhm.x) / Math.LN2 / 4;
}
exports.getSurface = getSurface;
function ensureXYNumber(input) {
    return typeof input !== 'object' ? { x: input, y: input } : { ...input };
}
function ensureFWHM2D(fwhm, sd) {
    if (sd !== undefined) {
        let sdObject = ensureXYNumber(sd);
        return {
            x: Gaussian_1.widthToFWHM(2 * sdObject.x),
            y: Gaussian_1.widthToFWHM(2 * sdObject.y),
        };
    }
    else if (fwhm !== undefined) {
        return ensureXYNumber(fwhm);
    }
    else {
        throw new Error('ensureFWHM2D must have either fwhm or sd defined');
    }
}
//# sourceMappingURL=Gaussian2D.js.map