"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getData = exports.getFactor = exports.getArea = exports.fwhmToWidth = exports.widthToFWHM = exports.fct = exports.Gaussian = void 0;
const constants_1 = require("../../../util/constants");
const erfinv_1 = __importDefault(require("../../../util/erfinv"));
const Shape1D_1 = require("../Shape1D");
class Gaussian extends Shape1D_1.Shape1D {
    constructor(options = {}) {
        super();
        const { fwhm = 500, sd, height } = options;
        this.fwhm = sd ? widthToFWHM(2 * sd) : fwhm;
        this.height =
            height === undefined
                ? Math.sqrt(-constants_1.GAUSSIAN_EXP_FACTOR / Math.PI) / this.fwhm
                : height;
    }
    fwhmToWidth(fwhm = this.fwhm) {
        return fwhmToWidth(fwhm);
    }
    widthToFWHM(width) {
        return widthToFWHM(width);
    }
    fct(x) {
        return fct(x, this.fwhm);
    }
    getArea() {
        return getArea({ fwhm: this.fwhm, height: this.height });
    }
    getFactor(area) {
        return getFactor(area);
    }
    getData(options = {}) {
        const { length, factor } = options;
        return getData({ fwhm: this.fwhm, height: this.height, factor, length });
    }
}
exports.Gaussian = Gaussian;
/**
 * Return a parameterized function of a gaussian shape (see README for equation).
 * @returns - the y value of gaussian with the current parameters.
 */
function fct(x, fwhm) {
    return Math.exp(constants_1.GAUSSIAN_EXP_FACTOR * Math.pow(x / fwhm, 2));
}
exports.fct = fct;
/**
 * Compute the value of Full Width at Half Maximum (FWHM) from the width between the inflection points.
 * for more information check the [mathworld page](https://mathworld.wolfram.com/GaussianFunction.html)
 * @returns fwhm
 */
function widthToFWHM(width) {
    return width * constants_1.ROOT_2LN2;
}
exports.widthToFWHM = widthToFWHM;
/**
 * Compute the value of width between the inflection points from Full Width at Half Maximum (FWHM).
 * for more information check the [mathworld page](https://mathworld.wolfram.com/GaussianFunction.html)
 * @param fwhm - Full Width at Half Maximum.
 * @returns width
 */
function fwhmToWidth(fwhm) {
    return fwhm / constants_1.ROOT_2LN2;
}
exports.fwhmToWidth = fwhmToWidth;
/**
 * Calculate the area of a specific shape.
 * @returns returns the area of the specific shape and parameters.
 */
function getArea(options) {
    let { fwhm, sd, height = 1 } = options;
    if (sd)
        fwhm = widthToFWHM(2 * sd);
    if (fwhm === undefined) {
        throw new Error('should pass fwhm or sd parameters');
    }
    return (height * constants_1.ROOT_PI_OVER_LN2 * fwhm) / 2;
}
exports.getArea = getArea;
/**
 * Calculate the number of times FWHM allows to reach a specific area coverage.
 * @param [area=0.9999] Expected area to be covered.
 * @returns
 */
function getFactor(area = 0.9999) {
    return Math.sqrt(2) * erfinv_1.default(area);
}
exports.getFactor = getFactor;
/**
 * Calculate intensity array of a gaussian shape.
 * @returns {Float64Array} Intensity values.
 */
function getData(options = {}) {
    let { length, factor = getFactor(), fwhm = 500, sd, height } = options;
    if (sd)
        fwhm = widthToFWHM(2 * sd);
    if (!height) {
        height = Math.sqrt(-constants_1.GAUSSIAN_EXP_FACTOR / Math.PI) / fwhm;
    }
    if (!length) {
        length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
        if (length % 2 === 0)
            length++;
    }
    const center = (length - 1) / 2;
    const data = new Float64Array(length);
    for (let i = 0; i <= center; i++) {
        data[i] = fct(i - center, fwhm) * height;
        data[length - 1 - i] = data[i];
    }
    return data;
}
exports.getData = getData;
//# sourceMappingURL=Gaussian.js.map