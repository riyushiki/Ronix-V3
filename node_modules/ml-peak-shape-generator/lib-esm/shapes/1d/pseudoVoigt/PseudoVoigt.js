import { GAUSSIAN_EXP_FACTOR, ROOT_2LN2_MINUS_ONE, ROOT_PI_OVER_LN2, } from '../../../util/constants';
import { Shape1D } from '../Shape1D';
import { fct as gaussian, getFactor as getFactorGaussian, } from '../gaussian/Gaussian';
import { fct as lorentzian, getFactor as getFactorLorentzian, } from '../lorentzian/Lorentzian';
export class PseudoVoigt extends Shape1D {
    constructor(options = {}) {
        super();
        const { fwhm = 500, height, mu = 0.5 } = options;
        this.mu = mu;
        this.fwhm = fwhm;
        this.height =
            height === undefined
                ? 1 /
                    ((mu / Math.sqrt(-GAUSSIAN_EXP_FACTOR / Math.PI)) * fwhm +
                        ((1 - mu) * fwhm * Math.PI) / 2)
                : height;
    }
    fwhmToWidth(fwhm = this.fwhm, mu = this.mu) {
        return fwhmToWidth(fwhm, mu);
    }
    widthToFWHM(width, mu = this.mu) {
        return widthToFWHM(width, mu);
    }
    fct(x) {
        return fct(x, this.fwhm, this.mu);
    }
    getArea() {
        return getArea({ fwhm: this.fwhm, height: this.height, mu: this.mu });
    }
    getFactor(area) {
        return getFactor(area);
    }
    getData(options = {}) {
        const { length, factor } = options;
        return getData({
            fwhm: this.fwhm,
            height: this.height,
            mu: this.mu,
            factor,
            length,
        });
    }
}
/**
 * Return a parameterized function of a pseudo voigt shape (see README for equation).
 * @param x - x value to calculate.
 * @param fwhm - full width half maximum
 * @returns - the y value of pseudo voigt with the current parameters.
 */
export function fct(x, fwhm, mu) {
    return (1 - mu) * lorentzian(x, fwhm) + mu * gaussian(x, fwhm);
}
/**
 * Compute the value of Full Width at Half Maximum (FWHM) from the width between the inflection points.
 * @param width - Width between the inflection points
 * @param [mu=0.5] Ratio of gaussian contribution in the shape
 * @returns fwhm
 */
export function widthToFWHM(width, mu = 0.5) {
    return width * (mu * ROOT_2LN2_MINUS_ONE + 1);
}
/**
 * Compute the value of width between the inflection points from Full Width at Half Maximum (FWHM).
 * @param fwhm - Full Width at Half Maximum.
 * @param [mu=0.5] Ratio of gaussian contribution in the shape
 * @returns width
 */
export function fwhmToWidth(fwhm, mu = 0.5) {
    return fwhm / (mu * ROOT_2LN2_MINUS_ONE + 1);
}
/**
 * Calculate the area of a specific shape.
 * @returns returns the area of the specific shape and parameters.
 */
export function getArea(options) {
    const { fwhm, height = 1, mu = 0.5 } = options;
    if (fwhm === undefined) {
        throw new Error('should pass fwhm or sd parameters');
    }
    return (fwhm * height * (mu * ROOT_PI_OVER_LN2 + (1 - mu) * Math.PI)) / 2;
}
/**
 * Calculate the number of times FWHM allows to reach a specific area coverage.
 * @param [area=0.9999] Expected area to be covered.
 * @returns
 */
export function getFactor(area = 0.9999, mu = 0.5) {
    return mu < 1 ? getFactorLorentzian(area) : getFactorGaussian(area);
}
/**
 * Calculate intensity array of a pseudo voigt shape.
 * @returns {Float64Array} y values
 */
export function getData(options = {}) {
    let { length, factor = getFactor(), fwhm = 500, height, mu = 0.5 } = options;
    if (!height) {
        height =
            1 /
                ((mu / Math.sqrt(-GAUSSIAN_EXP_FACTOR / Math.PI)) * fwhm +
                    ((1 - mu) * fwhm * Math.PI) / 2);
    }
    if (!length) {
        length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
        if (length % 2 === 0)
            length++;
    }
    const center = (length - 1) / 2;
    const data = new Float64Array(length);
    for (let i = 0; i <= center; i++) {
        data[i] = fct(i - center, fwhm, mu) * height;
        data[length - 1 - i] = data[i];
    }
    return data;
}
//# sourceMappingURL=PseudoVoigt.js.map